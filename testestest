"""
Defines internal RISA messages and methods for working with messages.
"""
#these are from risa/messages

# Leidos Copyright 2023

# DISTRIBUTION D: Distribution authorized to Department of Defense and U.S. DoD
# contractors only; Proprietary Information; Export Controlled; Oct 2021. Other
# requests for this document shall be referred to Naval Research Laboratory, 4555
# Overlook Avenue SW, Washington, DC 20375-5320.

from dataclasses import dataclass
from typing import Any, Dict, Union, Tuple, List
from uuid import UUID

import enum

from risa.connections import RabbitMqBasicConsumeCallbackData
from risa.rf_descriptor_types import EmitterDescriptorWord


def check_inclusive_bounds(
    property_name: str,
    value,
    minimum=0,
    maximum=100,
    allowed_types: Tuple = (float, int),
    include_minimum: bool = True,
    include_maximum: bool = True,
) -> None:
    """
    Check if a given number is one of the allowed types and within [minimum, maximum].

    Parameters
    ----------
    property_name : str
        Name of the property being checked

    value : Any
        Value to check.  Must be one of allowed_types

    minimum : Any, default=0
        Value to compare as a lower bound.

    maximum : Any, default=100
        Value to compare as an upper bound.

    allowed_types : tuple, default=(float, int)
        Allowed types for value

    include_minimum : bool, default=True
        Whether the minimum should be inclusive

    include_maximum : bool, default=True
        Whether the maximum should be inclusive

    Raises
    ------
    ValueError
        If value is not one of the allowed types
    ValueError
        If value is not >= minimum or value is not <= maximum.
    """
    if not isinstance(value, allowed_types):
        raise ValueError(f"{property_name} must be one of {allowed_types}")

    if include_minimum and value < minimum:
        raise ValueError(f"{property_name} must be >= {minimum}")
    elif include_minimum is False and value <= minimum:
        raise ValueError(f"{property_name} must be > {minimum}")

    if include_maximum and value > maximum:
        raise ValueError(f"{property_name} must be <= {maximum}")
    elif include_maximum is False and value >= maximum:
        raise ValueError(f"{property_name} must be < {maximum}")


def check_types(value: Any, field: str, allowed_types: Union[Any, Tuple]) -> None:
    """
    Raise a ValueError for the given field if the given value is not one of the allowed types.

    Parameters
    ----------
    value : Any
        The value to check

    field : str
        The name of the field that is not one of the allowed_types

    allowed_types : Union[Any, Tuple]
        The allowed types for the field

    Raises
    ------
    ValueError
    """
    if not isinstance(value, allowed_types):
        if isinstance(allowed_types, tuple) and len(allowed_types) == 1:
            raise ValueError(f"{field} must be a(n) {allowed_types}")
        raise ValueError(f"{field} must be one of {allowed_types}")


def check_optional_type(obj: object, field: str, allowed_types: Union[Any, Tuple]):
    """
    Check if an optional field has one of the allowed types.

    Parameters
    ----------
    obj: object
        The object to check

    field: str
        The attribute / field / property in the object to check.  If it is not
        None, then the type is compared against ``allowed_types``.

    allowed_types: Union[Any, Tuple]
        The type(s) to check against obj.field

    Raises
    ------
    ValueError
        If the value for obj.field is not one of the allowed types
    """
    value = getattr(obj, field)
    if value is not None:
        check_types(value=value, field=field, allowed_types=allowed_types)


def check_object_field(obj: Any, field: str, allowed_types: Union[Any, Tuple]):
    """
    Check if the field in the object is one of the allowed types or raise a
    ValueError.

    Parameters
    ----------
    obj : Any
        The object to check

    field : str
        The name of the attribute / property / field in the object

    allowed_types : Union[Any, Tuple]
        The types to check against ``obj.field``

    Raises
    ------
    ValueError
        If ``not isinstance(obj.field, allowed_types)) == True``
    """
    value = getattr(obj, field)
    check_types(value=value, field=field, allowed_types=allowed_types)


def check_object_list(
    obj: Any, field: str, allowed_types: Union[Any, Tuple], allow_empty: bool = False
):
    """
    Check if the field in the object is a list and if all of the items in the
    list one of the allowed types.

    Parameters
    ----------
    obj : Any
        The object to check

    field : str
        The name of the attribute / property / field in the object

    allowed_types : Union[Any, Tuple]
        The types to check against for each item in ``obj.field``

    allow_empty : bool
        Whether the list can be empty

    Raises
    ------
    ValueError
        If ``not isinstance(obj.field. list) == True``

    ValueError
        If ``not isinstance(obj.field[idx], allowed_types)) == True`` for each
        ``idx`` in ``obj.field``.
    """
    values = getattr(obj, field)
    if not isinstance(values, list):
        raise ValueError(f"{field} must be a list")
    if not allow_empty and len(values) == 0:
        raise ValueError(f"{field} must have at least one item")
    for idx, item in enumerate(values):
        check_types(value=item, field=f"{field}[{idx}]", allowed_types=allowed_types)


def parse_optional(
    data: Dict[str, Any], field: str, from_dict_class: Any = None, default=None
):
    """
    Parse an optional field from the given data.

    Parameters
    ----------
    data: dict
        The data to parse the optional field from

    field: str
        The name of the field to check in ``data``

    from_dict_class: Any, default=None
        The object to use for converting ``data[field]``.

        If not specified, then the field's value, if any, will be returned.

        Otherwise, the result of this class's ``from_dict`` method will be
        returned.

    default: Any, default=None
        The default value to return if the field is not found.
    """
    value = default
    if field in data:
        if from_dict_class:
            value = from_dict_class.from_dict(data[field])
        else:
            value = data[field]
    return value


def parse_optional_list(
    data: Dict[str, Any], field: str, from_dict_class: Any = None, default=None
):
    """
    Parse an optional list as a field from the given data.  If specified, each
    item in the list must be convertible using the ``from_dict_class``

    Parameters
    ----------
    data: dict
        The data to parse the optional list from

    field: str
        The name of the list to check in ``data``

    from_dict_class: Any, default=None
        The object to use for converting ``data[field][idx]``.

        If not specified, then the entire list will be returned

    default: Any, default=None
        The default value to return if the field is not found in ``data``.
    """
    value = default
    if field in data:
        if from_dict_class:
            value = [from_dict_class.from_dict(item) for item in data[field]]
        else:
            value = data[field]
    return value


def check_optional_list(
    obj: object, field: str, allowed_types: Union[Any, Tuple], allow_empty: bool = False
):
    """
    Check if an optional field has one of the allowed types.

    Parameters
    ----------
    obj: object
        The object to check

    field: str
        The attribute / field / property in the object to check.  If it is not
        None and ``allow_empty`` is False, then each value in the list is
        compared against ``allowed_types``.

    allowed_types: Union[Any, Tuple]
        The type(s) to check for each value in obj.field

    allow_empty: bool, default=False
        Whether the optional list can be empty

    Raises
    ------
    ValueError
        If ``not isinstance(obj.field. list) == True``

    ValueError
        If ``allow_empty == False and len(obj.field) == 0``

    ValueError
        If ``not isinstance(obj.field[idx], allowed_types)) == True`` for each
        ``idx`` in ``obj.field``.
    """
    value = getattr(obj, field)
    if value is not None:
        check_object_list(
            obj, field, allowed_types=allowed_types, allow_empty=allow_empty
        )


def append_optional_value(
    data: Dict[str, Any],
    field: str,
    value: Any,
    to_dict_class: bool = False,
    to_str: bool = False,
):
    """
    Append an optional value to the given dictionary.

    Parameters
    ----------
    data : Dict[str, Any]
        The dictionary to update

    field : str
        The name of the field in the dictionary to store the value to

    value : Any
        The value to store

    to_dict_class : bool, default=False
        Whether to call ``value.to_dict()`` when storing
        Takes precedence over ``to_str``

    to_str : bool, default=False
        Whether to call ``str(value)`` when storing.
        ``to_dict_class`` must be ``False`` for this to have any effect.
    """
    if value is not None:
        if to_dict_class:
            data[field] = value.to_dict()
        elif to_str:
            data[field] = str(value)
        else:
            data[field] = value


def append_optional_list(
    data: Dict[str, Any],
    field: str,
    value_list: List[Any],
    to_dict_class: bool = False,
    to_str: bool = False,
):
    """
    Append an optional list of values to the given dictionary.

    Parameters
    ----------
    data : Dict[str, Any]
        The dictionary to update

    field : str
        The name of the field in the dictionary to store the values to

    value_list : List[Any]
        The values to store

    to_dict_class : bool, default=False
        Whether to call ``value.to_dict()`` for each value in the list when storing.
        Takes precedence over ``to_str``.

    to_str : bool, default=False
        Whether to call ``str(value)`` for each value in the list when storing.
        ``to_dict_class`` must be ``False`` for this to have any effect.
    """
    if value_list is not None:
        if to_dict_class:
            data[field] = to_dict_list(value_list)
        elif to_str:
            data[field] = [str(obj) for obj in value_list]
        else:
            data[field] = value_list


def from_dict_list(value_list: List[Any], from_dict_class: Any) -> List[Any]:
    """
    Call ``from_dict_class.from_dict(value)`` for each value in a given list.

    Parameters
    ----------
    value_list : List[Any]
        The values to convert from dictionary representations

    from_dict_class: Any
        The class to use for converting the dictionary.

    Returns
    -------
    List of objects parsed from dictionary representations
    """
    return [from_dict_class.from_dict(obj) for obj in value_list]


def to_dict_list(value_list: List[Any]) -> List[Dict[str, Any]]:
    """
    Call ``value.to_dict()`` for each value in a given list

    Parameters
    ----------
    value_list : List[Any]
        The values to convert to dictionary representations

    Returns
    -------
    List of dictionary representations of the given values
    """
    return [obj.to_dict() for obj in value_list]


def parse_enum_from_dict(data: Dict[str, Any], field: str, enum_class):
    """
    Convert data[field] to a value from the given enum class.

    Raises
    ------
    ValueError
        If data[field] cannot be converted to the enum
    """
    try:
        return enum_class[data[field]]
    except KeyError as exc:
        names = [str(name) for name in enum_class]
        raise ValueError(f"{field} must be one of {names}") from exc


def parse_optional_enum(
    data: Dict[str, Any], field: str, enum_class: Any, default=None
):
    """
    Parse an optional field from the given data.

    Parameters
    ----------
    data: dict
        The data to parse the optional field from

    field: str
        The name of the field to check in ``data``

    enum_class: Any
        The enumeration to use for converting ``data[field]``.

    default: Any, default=None
        The default value to return if the field is not found.
    """
    value = default
    if field in data:
        value = enum_class[data[field]]
    return value


@dataclass(frozen=True)
class NackGuidance:
    """
    Defines a class for sending negative acknowledgements (Nack)
    """

    error_code: int
    reason: Union[str, None] = None


@dataclass(frozen=True)
class AckNackGuidance:
    """
    Defines a class for providing positive acknowledgements (Ack) or negative
    acknowledgements (Nack)
    """

    message_id: Union[str, UUID]
    nack: Union[NackGuidance, None] = None


@dataclass(frozen=True)
class Status:
    """
    Defines a class for providing status messages.
    """

    name: str
    uptime: Union[int, float]
    reporting_interval: Union[int, float]

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to a python dictionary object.

        Returns
        -------
        Dict[str, Any]
            Python dictionary representing this class.
        """
        return {
            "name": self.name,
            "uptime": self.uptime,
            "reporting_interval": self.reporting_interval,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Status":
        """
        Convert a python dictionary to a Status object.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary to convert

        Returns
        -------
        Status object

        Raises
        ------
        KeyError
            If a field is missing
        """
        name = data["name"]
        uptime = data["uptime"]
        reporting_interval = data["reporting_interval"]
        return Status(name=name, uptime=uptime, reporting_interval=reporting_interval)

    @classmethod
    def from_callback_data(
        cls, callback_data: RabbitMqBasicConsumeCallbackData
    ) -> "Status":
        """
        Convert data received from RMQ into a Status message

        Parameters
        ----------
        callback_data : :py:class:`~risa.connections.RabbitMqBasicConsumeCallbackData`
            The data to convert into a Status Message

        Returns
        -------
        Status
        """
        return cls.from_dict(callback_data.json_data)


def create_ack_guidance(message_id: Union[str, UUID]) -> AckNackGuidance:
    """
    Create an Ack for the given message id.

    Parameters
    ----------
    message_id : Union[str, UUID]
        The message to acknowledge

    Returns
    -------
    AckNackGuidance
    """
    return AckNackGuidance(message_id=message_id)


def create_nack_guidance(
    message_id: Union[str, UUID], error_code: int, reason: str = None
) -> AckNackGuidance:
    """
    Create a Nack for the given message id, with the given error code an optional reason.

    Parameters
    ----------
    message_id : Union[str, UUID]
        The message to nack

    error_code : int
        The simple reason for the negative acknowledgement

    reason : str, default=None
        The longer reason for the negative acknowledgement

    Returns
    -------
    AckNackGuidance
    """
    nack = NackGuidance(error_code=error_code, reason=reason)
    return AckNackGuidance(message_id=message_id, nack=nack)


class RfMode(enum.IntEnum):
    """
    Defines RF Modes as a type
    """

    UNKNOWN = enum.auto()
    COMMS = enum.auto()
    PASSIVE_SENSOR = enum.auto()
    JAMMER = enum.auto()
    RADAR = enum.auto()

    def __str__(self):
        return self.name


class WaveformType(enum.IntEnum):
    """
    Defines waveform as a type
    """

    WF_UNKNOWN = enum.auto()
    WF_LTE = enum.auto()
    WF_WIFI = enum.auto()
    WF_ENG = enum.auto()
    WF_FIVEGATW = enum.auto()
    WF_PTDL = enum.auto()
    WF_CRIIS = enum.auto()
    WF_WNW = enum.auto()
    WF_SRW = enum.auto()
    WF_P5TCTS = enum.auto()
    WF_5G = enum.auto()

    def __str__(self):
        return self.name


class TrafficType(enum.IntEnum):
    """
    Defines application traffic type
    """

    TF_UNKNOWN = enum.auto()
    TF_VOICE = enum.auto()
    TF_VIDEO = enum.auto()
    TF_DATA = enum.auto()
    TF_MCAST_DATA = enum.auto()
    TF_NONE = enum.auto()

    def __str__(self):
        return self.name


class PathLossModelType(enum.IntEnum):
    """
    Defines path loss model as a type
    """

    PLM_UNKNOWN = enum.auto()
    PLM_FREESPACE = enum.auto()
    PLM_PRECOMPUTED = enum.auto()
    PLM_2RAY = enum.auto()

    def __str__(self):
        return self.name


class MobilityProfileType(enum.IntEnum):
    """
    defines mobility profile type
    """

    # TODO fixme for EMANE consistency
    MOB_UNKNOWN = 0
    MOB_STATIC = 1
    MOB_RANDOM_WAYPOINT = 2
    MOB_TRAJECTORY_FILE = 3
    MOB_CONSTANT_VELOCITY = 4

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class LocationType:
    """
    Defines 3D location
    """

    latitude: Union[float, int]
    longitude: Union[float, int]
    altitude: Union[float, int]

    def __post_init__(self):
        check_object_field(self, "latitude", (float, int))
        check_object_field(self, "longitude", (float, int))
        check_object_field(self, "altitude", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {
            "latitude": self.latitude,
            "longitude": self.longitude,
            "altitude": self.altitude,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LocationType":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        latitude = data["latitude"]
        longitude = data["longitude"]
        altitude = data["altitude"]
        return LocationType(latitude=latitude, longitude=longitude, altitude=altitude)


@dataclass(frozen=True)
class VelocityType:
    """
    Defines 3D velocity
    """

    x: Union[float, int]
    y: Union[float, int]
    z: Union[float, int]

    def __post_init__(self):
        check_object_field(self, "x", (float, int))
        check_object_field(self, "y", (float, int))
        check_object_field(self, "z", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {
            "x": self.x,
            "y": self.y,
            "z": self.z,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "VelocityType":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        x = data["x"]
        y = data["y"]
        z = data["z"]
        return VelocityType(x=x, y=y, z=z)


@dataclass(frozen=True)
class PolygonType:
    """
    Defines a polygon
    """

    loc: List[LocationType]
    """ A list of 3D locations """

    def __post_init__(self):
        check_object_list(self, "loc", LocationType, allow_empty=False)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {"loc": to_dict_list(self.loc)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolygonType":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        loc = from_dict_list(data["loc"], LocationType)
        return PolygonType(loc=loc)


@dataclass(frozen=True)
class PlmAreaTuple:
    """
    Defines pathloss model area
    """

    plm: PathLossModelType = PathLossModelType.PLM_UNKNOWN
    geoarea: Union[PolygonType, None] = None

    def __post_init__(self):
        check_object_field(self, "plm", PathLossModelType)
        check_optional_type(self, "geoarea", PolygonType)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {"plm": str(self.plm)}
        append_optional_value(data, "geoarea", self.geoarea, to_dict_class=True)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PlmAreaTuple":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        plm = PathLossModelType[data["plm"]]
        geoarea = parse_optional(data, "geoarea", from_dict_class=PolygonType)
        return PlmAreaTuple(plm=plm, geoarea=geoarea)


@dataclass(frozen=True)
class TerrainInfoType:
    """
    Defines pathloss model areas
    """

    plm_areas: List[PlmAreaTuple]

    def __post_init__(self):
        check_object_list(self, "plm_areas", PlmAreaTuple, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {"plmAreas": to_dict_list(self.plm_areas)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TerrainInfoType":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        plm_areas = from_dict_list(data["plmAreas"], PlmAreaTuple)
        return TerrainInfoType(plm_areas=plm_areas)


@dataclass(frozen=True)
class MissionTrafficParams:
    """
    Defines traffic parameters for a mission
    """

    tf_type: Union[TrafficType, None] = None
    start_time: Union[float, int, None] = None
    end_time: Union[float, int, None] = None
    data_size: Union[int, None] = None
    avg_rate: Union[float, int, None] = None
    dst_id: Union[int, None] = None

    def __post_init__(self):
        check_optional_type(self, "tf_type", TrafficType)
        check_optional_type(self, "start_time", (float, int))
        check_optional_type(self, "end_time", (float, int))
        check_optional_type(self, "data_size", int)
        check_optional_type(self, "avg_rate", (float, int))
        check_optional_type(self, "dst_id", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "tfType", self.tf_type, to_str=True)
        append_optional_value(data, "startTime", self.start_time)
        append_optional_value(data, "endTime", self.end_time)
        append_optional_value(data, "dataSize", self.data_size)
        append_optional_value(data, "avgRate", self.avg_rate)
        append_optional_value(data, "dstId", self.dst_id)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MissionTrafficParams":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        tf_type = parse_optional_enum(data, "tfType", TrafficType)
        start_time = parse_optional(data, "startTime")
        end_time = parse_optional(data, "endTime")
        data_size = parse_optional(data, "dataSize")
        avg_rate = parse_optional(data, "avgRate")
        dst_id = parse_optional(data, "dstId")
        return MissionTrafficParams(
            tf_type=tf_type,
            start_time=start_time,
            end_time=end_time,
            data_size=data_size,
            avg_rate=avg_rate,
            dst_id=dst_id,
        )


@dataclass(frozen=True)
class WaveformInfo:
    """
    Defines waveform parameters
    """

    type: Union[WaveformType, None] = None
    min_frequency_hz: Union[float, int, None] = None
    max_frequency_hz: Union[float, int, None] = None
    channel_bw_hz: Union[float, int, None] = None
    tx_power_dbm: Union[float, int, None] = None
    fec_gain: Union[float, int, None] = None
    mary: Union[int, None] = None
    b: Union[int, None] = None
    hop_rate: Union[float, int, None] = None
    noise_figure: Union[float, int, None] = None

    def __post_init__(self):
        check_optional_type(self, "type", WaveformType)
        check_optional_type(self, "min_frequency_hz", (float, int))
        check_optional_type(self, "max_frequency_hz", (float, int))
        check_optional_type(self, "channel_bw_hz", (float, int))
        check_optional_type(self, "tx_power_dbm", (float, int))
        check_optional_type(self, "fec_gain", (float, int))
        check_optional_type(self, "mary", int)
        check_optional_type(self, "b", int)
        check_optional_type(self, "hop_rate", (float, int))
        check_optional_type(self, "noise_figure", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "type", self.type, to_str=True)
        append_optional_value(data, "minFrequencyHz", self.min_frequency_hz)
        append_optional_value(data, "maxFrequencyHz", self.max_frequency_hz)
        append_optional_value(data, "channelBWHz", self.channel_bw_hz)
        append_optional_value(data, "txPowerDbm", self.tx_power_dbm)
        append_optional_value(data, "fecGain", self.fec_gain)
        append_optional_value(data, "Mary", self.mary)
        append_optional_value(data, "B", self.b)
        append_optional_value(data, "hopRate", self.hop_rate)
        append_optional_value(data, "noiseFigure", self.noise_figure)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "WaveformInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        waveform_type = parse_optional_enum(data, "type", WaveformType)
        min_frequency_hz = parse_optional(data, "minFrequencyHz")
        max_frequency_hz = parse_optional(data, "maxFrequencyHz")
        channel_bw_hz = parse_optional(data, "channelBWHz")
        tx_power_dbm = parse_optional(data, "txPowerDbm")
        fec_gain = parse_optional(data, "fecGain")
        mary = parse_optional(data, "Mary")
        b = parse_optional(data, "B")
        hop_rate = parse_optional(data, "hopRate")
        noise_figure = parse_optional(data, "noiseFigure")
        return WaveformInfo(
            type=waveform_type,
            min_frequency_hz=min_frequency_hz,
            max_frequency_hz=max_frequency_hz,
            channel_bw_hz=channel_bw_hz,
            tx_power_dbm=tx_power_dbm,
            fec_gain=fec_gain,
            mary=mary,
            b=b,
            hop_rate=hop_rate,
            noise_figure=noise_figure,
        )


@dataclass(frozen=True)
class AntennaProfileInfo:
    """
    Defines antenna profile information
    """

    profile_id: Union[int, None] = None
    profile_info: Union[str, None] = None

    def __post_init__(self):
        check_optional_type(self, "profile_id", int)
        check_optional_type(self, "profile_info", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "profileId", self.profile_id)
        append_optional_value(data, "profileInfo", self.profile_info)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AntennaProfileInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        profile_id = parse_optional(data, "profileId")
        profile_info = parse_optional(data, "profileInfo")
        return AntennaProfileInfo(profile_id=profile_id, profile_info=profile_info)


@dataclass(frozen=True)
class RadioInterfaceScen:
    """
    Defines radio interface for a scenario
    """

    antenna_profiles: List[AntennaProfileInfo]
    """ list of antenna profile information """

    interface_num: Union[int, None] = None

    waveform_info: Union[WaveformInfo, None] = None
    """ defines waveform scenario info (normally applicable to COMMS only) """

    tx_distort_profile: Union[str, None] = None
    """ defines transmit signal distortion profile (normally applicable to COMMS only) """

    rx_distort_profile: Union[str, None] = None
    """ defines received signal distortion profile """

    def __post_init__(self):
        check_object_list(
            self, "antenna_profiles", AntennaProfileInfo, allow_empty=True
        )
        check_optional_type(self, "interface_num", int)
        check_optional_type(self, "waveform_info", WaveformInfo)
        check_optional_type(self, "tx_distort_profile", str)
        check_optional_type(self, "rx_distort_profile", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {"antennaProfiles": to_dict_list(self.antenna_profiles)}
        append_optional_value(data, "interfaceNum", self.interface_num)
        append_optional_value(
            data, "waveformInfo", self.waveform_info, to_dict_class=True
        )
        append_optional_value(data, "txDistortProfile", self.tx_distort_profile)
        append_optional_value(data, "rxDistortProfile", self.rx_distort_profile)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioInterfaceScen":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        antenna_profiles = from_dict_list(data["antennaProfiles"], AntennaProfileInfo)
        interface_num = parse_optional(data, "interfaceNum")
        waveform_info = parse_optional(data, "waveformInfo", WaveformInfo)
        tx_distort_profile = parse_optional(data, "txDistortProfile")
        rx_distort_profile = parse_optional(data, "rxDistortProfile")
        return RadioInterfaceScen(
            antenna_profiles=antenna_profiles,
            interface_num=interface_num,
            waveform_info=waveform_info,
            tx_distort_profile=tx_distort_profile,
            rx_distort_profile=rx_distort_profile,
        )


@dataclass(frozen=True)
class NodeScenInfo:
    """
    Node scenario information
    """

    radio_configs: List[RadioInterfaceScen]
    """ radio configurations """

    local_id: Union[str, None] = None
    """ local id for the node """

    mission_traffic: Union[MissionTrafficParams, None] = None
    """ mission traffic (only applicable to COMMS) """

    scan_plan: Union[str, None] = None
    """ scan plan (only applicable to PASSIVE_SENSOR) """

    location: Union[LocationType, None] = None
    """ node location """

    velocity: Union[VelocityType, None] = None
    """ node velocity """

    def __post_init__(self):
        check_object_list(self, "radio_configs", RadioInterfaceScen, allow_empty=True)
        check_optional_type(self, "local_id", str)
        check_optional_type(self, "mission_traffic", MissionTrafficParams)
        check_optional_type(self, "scan_plan", str)
        check_optional_type(self, "location", LocationType)
        check_optional_type(self, "velocity", VelocityType)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {"radioConfigs": to_dict_list(self.radio_configs)}
        append_optional_value(data, "localId", self.local_id)
        append_optional_value(
            data, "missionTraffic", self.mission_traffic, to_dict_class=True
        )
        append_optional_value(data, "scanPlan", self.scan_plan)
        append_optional_value(data, "location", self.location, to_dict_class=True)
        append_optional_value(data, "velocity", self.velocity, to_dict_class=True)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NodeScenInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        radio_configs = from_dict_list(data["radioConfigs"], RadioInterfaceScen)
        local_id = parse_optional(data, "localId")
        mission_traffic = parse_optional(data, "missionTraffic", MissionTrafficParams)
        scan_plan = parse_optional(data, "scanPlan")
        location = parse_optional(data, "location", LocationType)
        velocity = parse_optional(data, "velocity", VelocityType)
        return NodeScenInfo(
            radio_configs=radio_configs,
            local_id=local_id,
            mission_traffic=mission_traffic,
            scan_plan=scan_plan,
            location=location,
            velocity=velocity,
        )


@dataclass(frozen=True)
class NetworkScenInfo:
    """
    Network Scenario information
    """

    node_info_list: List[NodeScenInfo]
    """ set of node configurations """

    net_id: Union[str, None] = None
    """ network id """

    # TODO turn into list?
    start_time: Union[float, int, None] = None
    """ start time """
    end_time: Union[float, int, None] = None
    """ end time """

    mobility_type: Union[MobilityProfileType, None] = None
    """ mobility profile for the network """

    rf_mode: Union[RfMode, None] = None
    """ RF mode """

    def __post_init__(self):
        check_object_list(self, "node_info_list", NodeScenInfo, allow_empty=True)
        check_optional_type(self, "net_id", str)
        check_optional_type(self, "start_time", (float, int))
        check_optional_type(self, "end_time", (float, int))
        check_optional_type(self, "mobility_type", MobilityProfileType)
        check_optional_type(self, "rf_mode", RfMode)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {"nodeInfoList": to_dict_list(self.node_info_list)}
        append_optional_value(data, "netId", self.net_id)
        append_optional_value(data, "startTime", self.start_time)
        append_optional_value(data, "endTime", self.end_time)
        append_optional_value(data, "mobilityType", self.mobility_type, to_str=True)
        append_optional_value(data, "rfMode", self.rf_mode, to_str=True)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetworkScenInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        node_info_list = from_dict_list(data["nodeInfoList"], NodeScenInfo)
        net_id = parse_optional(data, "netId")
        start_time = parse_optional(data, "startTime")
        end_time = parse_optional(data, "endTime")
        mobility_type = parse_optional_enum(data, "mobilityType", MobilityProfileType)
        rf_mode = parse_optional_enum(data, "rfMode", RfMode)
        return NetworkScenInfo(
            node_info_list=node_info_list,
            net_id=net_id,
            start_time=start_time,
            end_time=end_time,
            mobility_type=mobility_type,
            rf_mode=rf_mode,
        )


@dataclass(frozen=True)
class Scenario:
    """
    Defines an emulation scenario
    """

    net_info_list: List[NetworkScenInfo]
    """ set of network configurations """

    scenario_id: Union[int, None] = None
    """ scenario id of this message """

    time_period: Union[float, int, None] = None
    """ epoch time period of this message """

    terrain_info: Union[TerrainInfoType, None] = None
    """ terrain information for this message """

    def __post_init__(self):
        check_object_list(self, "net_info_list", NetworkScenInfo, allow_empty=True)
        check_optional_type(self, "scenario_id", int)
        check_optional_type(self, "time_period", (float, int))
        check_optional_type(self, "terrain_info", TerrainInfoType)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {"netInfoList": to_dict_list(self.net_info_list)}
        append_optional_value(data, "scenarioId", self.scenario_id)
        append_optional_value(data, "timePeriod", self.time_period)
        append_optional_value(
            data, "terrainInfo", self.terrain_info, to_dict_class=True
        )
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Scenario":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        net_info_list = from_dict_list(data["netInfoList"], NetworkScenInfo)
        scenario_id = parse_optional(data, "scenarioId")
        time_period = parse_optional(data, "timePeriod")
        terrain_info = parse_optional(data, "terrainInfo", TerrainInfoType)
        return Scenario(
            net_info_list=net_info_list,
            scenario_id=scenario_id,
            time_period=time_period,
            terrain_info=terrain_info,
        )


@dataclass(frozen=True)
class EmulationPlan:
    """
    An emulation that needs to be run
    """

    plan_id: UUID
    """ Unique id for the emulation plan to run """

    scenario: Scenario
    """ The scenario to run """

    jammers: Union[List[EmitterDescriptorWord], None] = None
    """ Optional jammer information (e.g., as detected by RISF).
    Must have at least one if specified """

    def __post_init__(self):
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "scenario", Scenario)
        check_optional_list(self, "jammers", EmitterDescriptorWord)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {
            "planId": str(self.plan_id),
            "scenario": self.scenario.to_dict(),
        }
        if self.jammers is not None:
            data["jammers"] = [item.to_dict() for item in self.jammers]
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "EmulationPlan":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        plan_id = UUID(data["planId"])
        scenario = Scenario.from_dict(data["scenario"])
        jammers = parse_optional_list(
            data, "jammers", from_dict_class=EmitterDescriptorWord
        )
        return EmulationPlan(plan_id=plan_id, scenario=scenario, jammers=jammers)


@dataclass(frozen=True)
class StatInfo:
    """
    Captures basic statistics
    """

    min: Union[float, int, None] = None
    avg: Union[float, int, None] = None
    max: Union[float, int, None] = None

    def __post_init__(self):
        check_optional_type(self, "min", (float, int))
        check_optional_type(self, "avg", (float, int))
        check_optional_type(self, "max", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "min", self.min)
        append_optional_value(data, "avg", self.avg)
        append_optional_value(data, "max", self.max)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "StatInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        stat_min = parse_optional(data, "min")
        avg = parse_optional(data, "avg")
        stat_max = parse_optional(data, "max")
        return StatInfo(min=stat_min, avg=avg, max=stat_max)


@dataclass(frozen=True)
class RadioStats:
    """
    Radio statistics
    """

    interface_num: Union[int, None] = None
    num_mac_transmits: Union[int, None] = None
    num_mac_retries: Union[int, None] = None
    num_mac_receptions: Union[int, None] = None
    inr_db: Union[StatInfo, None] = None
    sinr_db: Union[StatInfo, None] = None

    def __post_init__(self):
        check_optional_type(self, "interface_num", int)
        check_optional_type(self, "num_mac_transmits", int)
        check_optional_type(self, "num_mac_retries", int)
        check_optional_type(self, "num_mac_receptions", int)
        check_optional_type(self, "inr_db", StatInfo)
        check_optional_type(self, "sinr_db", StatInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "interfaceNum", self.interface_num)
        append_optional_value(data, "numMacTransmits", self.num_mac_transmits)
        append_optional_value(data, "numMacRetries", self.num_mac_retries)
        append_optional_value(data, "numMacReceptions", self.num_mac_receptions)
        append_optional_value(data, "inrDb", self.inr_db, to_dict_class=True)
        append_optional_value(data, "sinrDb", self.sinr_db, to_dict_class=True)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioStats":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        interface_num = parse_optional(data, "interfaceNum")
        num_mac_transmits = parse_optional(data, "numMacTransmits")
        num_mac_retries = parse_optional(data, "numMacRetries")
        num_mac_receptions = parse_optional(data, "numMacReceptions")
        inr_db = parse_optional(data, "inrDb", StatInfo)
        sinr_db = parse_optional(data, "sinrDb", StatInfo)
        return RadioStats(
            interface_num=interface_num,
            num_mac_transmits=num_mac_transmits,
            num_mac_retries=num_mac_retries,
            num_mac_receptions=num_mac_receptions,
            inr_db=inr_db,
            sinr_db=sinr_db,
        )


@dataclass(frozen=True)
class CommStats:
    """
    Communication statistics
    """

    radio_stats: List[RadioStats]
    """ set of radio statistics """

    source_id: Union[str, None] = None
    """ brief ID of traffic source """

    recipient_id: Union[str, None] = None
    """ ID of traffic destination """

    start_time: Union[float, int, None] = None
    """ start time """

    end_time: Union[float, int, None] = None
    """ end time """

    num_tx_pkts: Union[StatInfo, None] = None
    """ number of packets sent """

    num_tx_bytes: Union[StatInfo, None] = None
    """ number of bytes sent """

    num_rx_pkts: Union[StatInfo, None] = None
    """ number of packets received """

    num_rx_bytes: Union[StatInfo, None] = None
    """ number of bytes received """

    percent_route_fails: Union[float, int, None] = None
    """ percentage of route failures """

    def __post_init__(self):
        check_object_list(self, "radio_stats", RadioStats, allow_empty=True)
        check_optional_type(self, "source_id", str)
        check_optional_type(self, "recipient_id", str)
        check_optional_type(self, "start_time", (float, int))
        check_optional_type(self, "end_time", (float, int))
        check_optional_type(self, "num_tx_pkts", StatInfo)
        check_optional_type(self, "num_tx_bytes", StatInfo)
        check_optional_type(self, "num_rx_pkts", StatInfo)
        check_optional_type(self, "num_rx_bytes", StatInfo)
        check_optional_type(self, "percent_route_fails", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {"radioStats": to_dict_list(self.radio_stats)}
        append_optional_value(data, "sourceId", self.source_id)
        append_optional_value(data, "recipientId", self.recipient_id)
        append_optional_value(data, "startTime", self.start_time)
        append_optional_value(data, "endTime", self.end_time)
        append_optional_value(data, "numTxPkts", self.num_tx_pkts, to_dict_class=True)
        append_optional_value(data, "numTxBytes", self.num_tx_bytes, to_dict_class=True)
        append_optional_value(data, "numRxPkts", self.num_rx_pkts, to_dict_class=True)
        append_optional_value(data, "numRxBytes", self.num_rx_bytes, to_dict_class=True)
        append_optional_value(data, "percentRouteFails", self.percent_route_fails)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CommStats":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        radio_stats = from_dict_list(data["radioStats"], RadioStats)
        source_id = parse_optional(data, "sourceId")
        recipient_id = parse_optional(data, "recipientId")
        start_time = parse_optional(data, "startTime")
        end_time = parse_optional(data, "endTime")
        num_tx_pkts = parse_optional(data, "numTxPkts", StatInfo)
        num_tx_bytes = parse_optional(data, "numTxBytes", StatInfo)
        num_rx_pkts = parse_optional(data, "numRxPkts", StatInfo)
        num_rx_bytes = parse_optional(data, "numRxBytes", StatInfo)
        percent_route_fails = parse_optional(data, "percentRouteFails")
        return CommStats(
            radio_stats=radio_stats,
            source_id=source_id,
            recipient_id=recipient_id,
            start_time=start_time,
            end_time=end_time,
            num_tx_pkts=num_tx_pkts,
            num_tx_bytes=num_tx_bytes,
            num_rx_pkts=num_rx_pkts,
            num_rx_bytes=num_rx_bytes,
            percent_route_fails=percent_route_fails,
        )


@dataclass(frozen=True)
class SensorStats:
    """
    Sensor statistics
    """

    interface_num: Union[int, None] = None
    snr_db: Union[StatInfo, None] = None
    rx_bw_hz: Union[float, int, None] = None

    def __post_init__(self):
        check_optional_type(self, "interface_num", int)
        check_optional_type(self, "snr_db", StatInfo)
        check_optional_type(self, "rx_bw_hz", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "interfaceNum", self.interface_num)
        append_optional_value(data, "snrDb", self.snr_db, to_dict_class=True)
        append_optional_value(data, "rxBwHz", self.rx_bw_hz)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SensorStats":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        interface_num = parse_optional(data, "interfaceNum")
        snr_db = parse_optional(data, "snrDb", StatInfo)
        rx_bw_hz = parse_optional(data, "rxBwHz")
        return SensorStats(
            interface_num=interface_num, snr_db=snr_db, rx_bw_hz=rx_bw_hz
        )


@dataclass(frozen=True)
class RxPhyInfo:
    """
    Physical receiver information
    """

    inr_db: Union[float, int, None] = None
    sinr_db: Union[float, int, None] = None

    def __post_init__(self):
        check_optional_type(self, "inr_db", (float, int))
        check_optional_type(self, "sinr_db", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "inrDb", self.inr_db)
        append_optional_value(data, "sinrDb", self.sinr_db)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RxPhyInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        inr_db = parse_optional(data, "inrDb")
        sinr_db = parse_optional(data, "sinrDb")
        return RxPhyInfo(inr_db=inr_db, sinr_db=sinr_db)


@dataclass(frozen=True)
class RxNetFlow:
    """
    Receiver network flow
    """

    net_id: Union[str, None] = None
    rx_id: Union[str, None] = None
    tx_id: Union[str, None] = None
    flow: Union[int, None] = None
    rx_count: Union[int, None] = None
    phy_info: Union[RxPhyInfo, None] = None

    def __post_init__(self):
        check_optional_type(self, "net_id", str)
        check_optional_type(self, "rx_id", str)
        check_optional_type(self, "tx_id", str)
        check_optional_type(self, "flow", int)
        check_optional_type(self, "rx_count", int)
        check_optional_type(self, "phy_info", RxPhyInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "netId", self.net_id)
        append_optional_value(data, "rxId", self.rx_id)
        append_optional_value(data, "txId", self.tx_id)
        append_optional_value(data, "flow", self.flow)
        append_optional_value(data, "rxCount", self.rx_count)
        append_optional_value(data, "phyInfo", self.phy_info, to_dict_class=True)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RxNetFlow":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        net_id = parse_optional(data, "netId")
        rx_id = parse_optional(data, "rxId")
        tx_id = parse_optional(data, "txId")
        flow = parse_optional(data, "flow")
        rx_count = parse_optional(data, "rxCount")
        phy_info = parse_optional(data, "phyInfo", RxPhyInfo)
        return RxNetFlow(
            net_id=net_id,
            rx_id=rx_id,
            tx_id=tx_id,
            flow=flow,
            rx_count=rx_count,
            phy_info=phy_info,
        )


@dataclass(frozen=True)
class TxNetFlow:
    """
    Transmitter network flow
    """

    net_id: Union[str, None] = None
    tx_id: Union[str, None] = None
    flow: Union[int, None] = None
    tx_count: Union[int, None] = None

    def __post_init__(self):
        check_optional_type(self, "net_id", str)
        check_optional_type(self, "tx_id", str)
        check_optional_type(self, "flow", int)
        check_optional_type(self, "tx_count", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "netId", self.net_id)
        append_optional_value(data, "txId", self.tx_id)
        append_optional_value(data, "flow", self.flow)
        append_optional_value(data, "txCount", self.tx_count)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TxNetFlow":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        net_id = parse_optional(data, "netId")
        tx_id = parse_optional(data, "txId")
        flow = parse_optional(data, "flow")
        tx_count = parse_optional(data, "txCount")
        return TxNetFlow(
            net_id=net_id,
            tx_id=tx_id,
            flow=flow,
            tx_count=tx_count,
        )


@dataclass(frozen=True)
class ReceiveReport:
    """
    Receiver network flow report
    """

    flows: List[RxNetFlow]
    """ set of comms profiles (enabled only if rfMode == COMMS) """

    def __post_init__(self):
        check_object_list(self, "flows", RxNetFlow, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {"rxNetFlows": to_dict_list(self.flows)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ReceiveReport":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        flows = from_dict_list(data["rxNetFlows"], RxNetFlow)
        return ReceiveReport(flows=flows)


@dataclass(frozen=True)
class TransmitReport:
    """
    Transmitter network flow report
    """

    flows: List[TxNetFlow]
    """ set of comms profiles (enabled only if rfMode == COMMS) """

    def __post_init__(self):
        check_object_list(self, "flows", TxNetFlow, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {"txNetFlows": to_dict_list(self.flows)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TransmitReport":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        flows = from_dict_list(data["txNetFlows"], TxNetFlow)
        return TransmitReport(flows=flows)


@dataclass(frozen=True)
class ScenarioResultInfo:
    """
    Scenario results
    """

    scenario_id: Union[int, None] = None
    """ scenario id """

    rx_report: Union[ReceiveReport, None] = None
    """ reception report """

    tx_report: Union[TransmitReport, None] = None
    """ transmit report """

    def __post_init__(self):
        check_optional_type(self, "scenario_id", int)
        check_optional_type(self, "rx_report", ReceiveReport)
        check_optional_type(self, "tx_report", TransmitReport)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        data = {}
        append_optional_value(data, "scenarioId", self.scenario_id)
        append_optional_value(data, "rxReport", self.rx_report, to_dict_class=True)
        append_optional_value(data, "txReport", self.tx_report, to_dict_class=True)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ScenarioResultInfo":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        scenario_id = parse_optional(data, "scenarioId")
        rx_report = parse_optional(data, "rxReport", ReceiveReport)
        tx_report = parse_optional(data, "txReport", TransmitReport)
        return ScenarioResultInfo(
            scenario_id=scenario_id,
            rx_report=rx_report,
            tx_report=tx_report,
        )


@dataclass(frozen=True)
class EmulationResults:
    """
    Emulation results
    """

    plan_id: UUID
    """ Unique id for the emulation plan that run """

    scenario_info_list: List[ScenarioResultInfo]
    """ set of reports """

    def __post_init__(self):
        check_object_field(self, "plan_id", UUID)
        check_object_list(
            self, "scenario_info_list", ScenarioResultInfo, allow_empty=True
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return JSON-compatible dictionary representation of this object.
        """
        return {
            "planId": str(self.plan_id),
            "scenarioInfoList": to_dict_list(self.scenario_info_list),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "EmulationResults":
        """
        Parse dictionary representation of this object.

        Parameters
        ----------
        data : Dict[str, Any]
            The data to parse

        Raises
        ------
        KeyError
            If a field is missing.

        ValueError
            If a field has an invalid value.
        """
        plan_id = UUID(data["planId"])
        scenario_info_list = from_dict_list(
            data["scenarioInfoList"], ScenarioResultInfo
        )
        return EmulationResults(plan_id=plan_id, scenario_info_list=scenario_info_list)




#these are from tranche2/messages
"""
Defines methods and functions for creating, parsing, and validating
Tranche2 JSON messages.
"""

# Leidos Copyright 2023
#
# DISTRIBUTION D: Distribution authorized to Department of Defense and U.S. DoD
# contractors only; Proprietary Information; Export Controlled; Oct 2021. Other
# requests for this document shall be referred to Naval Research Laboratory, 4555
# Overlook Avenue SW, Washington, DC 20375-5320.

from abc import ABC, abstractmethod
import enum
import json
import logging
import os
from pathlib import Path
from datetime import datetime as dt, timedelta
from dataclasses import dataclass, asdict
import re
from typing import Any, Dict, List, Tuple, Union, ClassVar
from uuid import UUID

import numpy as np

import jsonschema

from risa import util, validation
from risa.connections import RabbitMqBasicConsumeCallbackData
from risa.messages import (
    Status,
    append_optional_list,
    append_optional_value,
    check_inclusive_bounds,
    check_object_field,
    check_object_list,
    check_optional_list,
    check_optional_type,
    from_dict_list,
    parse_optional,
    parse_optional_list,
    to_dict_list,
    parse_enum_from_dict,
)

from .. import versioning

from . import checksum
from . import uuid5

logger = logging.getLogger("risa.tranche2.messages")

SCHEMA_DIR = os.environ.get(
    "RISA_SCHEMA_DIR",
    str(
        Path(__file__).parent.parent.parent.parent
        / "tranche2-message-formats"
        / "schemas"
    ),
)
if not os.path.isdir(SCHEMA_DIR):
    raise ImportError("Unable to find RISA_SCHEMA_DIR environment variable")

with open(os.path.join(SCHEMA_DIR, "VERSION.txt"), "rt", encoding="utf-8") as f:
    SCHEMA_VERSION_STR = f.read().strip()

    SCHEMA_MAJOR, SCHEMA_MINOR, SCHEMA_PATCH = (
        int(item) for item in SCHEMA_VERSION_STR.split(".")[:3]
    )

    # defines the minimum and maximum allowed versions for schemas
    SCHEMA_MIN_VERSION = versioning.SemanticVersion(
        major=SCHEMA_MAJOR, minor=SCHEMA_MINOR, patch=0
    )
    SCHEMA_MAX_VERSION = versioning.SemanticVersion(
        major=SCHEMA_MAJOR, minor=SCHEMA_MINOR + 1, patch=0
    )
    SCHEMA_VERSION = versioning.get_semantic_version(SCHEMA_VERSION_STR)


class TimeDurationInterface(ABC):
    """
    Defines an interface for computing time durations
    """

    @property
    @abstractmethod
    def sec(self) -> float:
        """
        Return the duration represented as seconds.
        """

    @property
    @abstractmethod
    def msec(self) -> float:
        """
        Return the duration represented as milliseconds.
        """

    @property
    @abstractmethod
    def usec(self) -> float:
        """
        Return the duration represented as microseconds.
        """


def get_deg_min_from_decimal(decimal: float) -> Tuple[float, float]:
    """
    Convert decimal degrees to DDMM.M format.

    Parameters
    ----------
    decimal : float
        The value to convert

    Returns
    -------
    Tuple[float, float]
        Degrees, minutes
    """
    deg = int(decimal)
    minutes = abs((decimal - deg) * 60)
    return (deg, minutes)


def get_signed_dec_min_str_from_decimal(
    decimal: float, *args, width_with_sign: Union[int, None] = None, **kwargs
) -> str:
    """
    Convert decimal degrees to DDMM.M format

    Parameters
    ----------
    decimal : float
        Value to convert

    width_with_sign : int, default=None
        The width of the formatted ``int(value)``.  This should include the
        ``+`` or ``-`` sign.

        If none, then no width or leading zeros will be applied.

    *args : list
        Arguments to pass to :py:meth:`get_signed_rounded_str` for converting
        minutes.

    **kwargs : dict
        Keyword arguments to pass to :py:meth:`get_signed_rounded_str` for
        converting minutes.

    Returns
    -------
    str
        Convert decimal into DDMM.M format
    """
    deg, minutes = get_deg_min_from_decimal(decimal)
    if width_with_sign is None:
        signed_str = f"{deg:+d}"
    else:
        signed_str = f"{deg:+0{width_with_sign}d}"
    rounded_minutes_str = get_signed_rounded_str(
        minutes, *args, width_with_sign=3, **kwargs
    )
    return f"{signed_str}{rounded_minutes_str[1:]}"


def get_deg_min_sec_from_decimal(decimal: float) -> Tuple[float, float, float]:
    """
    Convert decimal degrees to DDMMSS.S format.

    Parameters
    ----------
    decimal : float
        The value to convert

    Returns
    -------
    Tuple(float, float, float)
        Degrees, minutes, seconds
    """
    deg, minutes = get_deg_min_from_decimal(decimal)
    rounded_minutes = int(minutes)
    sec = (minutes - rounded_minutes) * 60
    return (deg, rounded_minutes, sec)


def get_signed_dec_min_sec_str_from_decimal(
    decimal: float, *args, width_with_sign: Union[int, None] = None, **kwargs
) -> str:
    """
    Convert decimal degrees to DDMMSS.S format

    Parameters
    ----------
    decimal : float
        Value to convert

    width_with_sign : int, default=None
        The width of the formatted ``int(value)``.  This should include the
        ``+`` or ``-`` sign.

        If none, then no width or leading zeros will be applied.

    *args : list
        Arguments to pass to :py:meth:`get_signed_rounded_str` for converting
        seconds.

    **kwargs : dict
        Keyword arguments to pass to :py:meth:`get_signed_rounded_str` for
        converting seconds.

    Returns
    -------
    str
        Convert decimal into DDMMSS.S format
    """
    deg, deg_min, sec = get_deg_min_sec_from_decimal(decimal)
    if width_with_sign is None:
        signed_str = f"{deg:+d}"
    else:
        signed_str = f"{deg:+0{width_with_sign}d}"
    rounded_sec_str = get_signed_rounded_str(sec, *args, width_with_sign=3, **kwargs)
    return f"{signed_str}{deg_min:02d}{rounded_sec_str[1:]}"


def get_signed_rounded_str(
    value: float, width_with_sign: Union[int, None] = None, tol: float = 1e-6
) -> str:
    """
    Convert value to a string.  Will check to see if the fractional portion
    of value is less than the given tolerance.

    If so, then ``int(value)`` will be formatted.

    Parameters
    ----------
    value : float
        The value to convert

    width_with_sign : int, default=None
        The width of the formatted ``int(value)``.  This should include the
        ``+`` or ``-`` sign.

        If none, then no width or leading zeros will be applied.

    tol : float, default=1e-6
        The tolerance to use for using ``int(value)`` by itself.

    Returns
    -------
    str
        Converted decimal degrees.
    """
    decimal_portion = int(value)
    fractional_portion = abs(value - decimal_portion)
    if width_with_sign is None:
        signed_str = f"{decimal_portion:+d}"
    else:
        signed_str = f"{decimal_portion:+0{width_with_sign}d}"
    if fractional_portion > tol:
        signed_str += f"{fractional_portion:.6f}".lstrip("0").rstrip("0")
    return signed_str


def get_timestamp_as_str(timestamp: dt) -> str:
    """
    Convert datetime object into UTC ISO 8601 timestamp string with millisecond
    accuracy.

    Parameters
    ----------
    timestamp : datetime.datetime
        The datetime object to convert

    Returns
    -------
    str
        UTC ISO 8601 timestamp string
    """
    return timestamp.isoformat(timespec="microseconds").rstrip("0") + "Z"


def get_timestamp_from_str(timestamp: str) -> dt:
    """
    Convert string into datetime.

    Parameters
    ----------
    timestamp : str
        The string to convert

    Returns
    -------
    datetime.datetime
        Converted timestamp
    """
    to_convert = timestamp
    if timestamp.endswith("Z"):
        to_convert = timestamp[:-1]
    # pad the decimal with zeros so that there are 6 places
    pieces = to_convert.split(".")
    # a valid timestamp string should end up with 2 pieces
    if len(pieces) == 2:
        nzeros = 6 - len(pieces[1])
        if nzeros > 0:
            pieces[1] += "0" * nzeros
            to_convert = ".".join(pieces)
    return dt.fromisoformat(to_convert)


def generate_message_id(message_type: str, timestamp: dt):
    """
    Generate a tranche2 message ID

    Parameters
    ----------
    message_type: str
        The type of message for the uuid generation

    timestamp: dt
        The datetime formatted timestamp

    Returns
    -------
    Returns a string for the generated UUID

    """
    return uuid5.get_tranche2_uuid5("risa-origin", message_type + timestamp.isoformat())


def append_checksum(message_envelope):
    """
    Modify message envelope to include a checksum

    Parameters
    ----------
    message_envelope: Dict
        The envelope to update
    """
    message_envelope["checksum"] = "0" * 32
    checksum.append(message_envelope)


def wrap_in_message_envelope(
    message_type_str: str,
    json_data: dict,
    known_version: str = None,
    known_message_id: UUID = None,
    known_timestamp: dt = None,
    known_checksum: str = None,
) -> Dict:
    """
    Create a Tranche2 Message Envelope dictionary.

    Parameters
    ----------
    message_type_str : str
        The type of message for the json_data payload

    json_data : dict
        Message payload

    known_version : str or None, default=None
        version field for the message envelope.

        If None, set to SCHEMA_VERSION_STR.

    known_message_id : UUID or None, default=None
        message id field for the message envelope.

        If None, computed based off the message type and timestamp with
        namespace ``risa-origin``.

    known_timestamp : datetime or None, default=None
        timestamp field for the message envelope.

        If None, computed as the current datetime ``datetime.now()``.

    known_checksum : str or None, default=None
        checksum field for the message envelope.

        If None, computed based off the dictionary contents when
        serialized to JSON with 32 0s checksum.
    """
    if known_version is None:
        version = SCHEMA_VERSION_STR
    else:
        version = known_version
    if known_timestamp is None:
        timestamp = dt.now()
    else:
        timestamp = known_timestamp
    if known_message_id is None:
        message_id = generate_message_id(message_type_str, timestamp)
    else:
        message_id = known_message_id
    message_envelope = {
        "version": version,
        "messageId": message_id,
        "timestamp": get_timestamp_as_str(timestamp),
        "message": {
            "type": message_type_str,
            "body": json_data,
        },
    }
    if known_checksum is None:
        append_checksum(message_envelope)
    else:
        message_envelope["checksum"] = known_checksum
    return message_envelope


def create_ack(request_message_id):
    ack = {
        "requestMessageId": request_message_id,
    }
    return wrap_in_message_envelope("Ack", ack)


class NackReason(enum.IntEnum):
    NotJson = 0
    InvalidChecksum = 1
    JsonSchemaValidationFailed = 2
    JsonSchemaVersionMismatch = 3
    UnsupportedOperation = 4
    InvalidRequest = 5


def create_nack(error_code, request_message_id=None, reason=None):
    nack = {
        "errorCode": error_code.value,
    }
    if request_message_id is not None:
        nack["requestMessageId"] = request_message_id
    if reason is not None:
        nack["reason"] = reason
    return wrap_in_message_envelope("Nack", nack)


def create_heartbeat(timeout, instanceId):
    heartbeat = {
        "timeout": get_timestamp_as_str(timeout),
        "instanceId": instanceId,
    }
    return wrap_in_message_envelope("Heartbeat", heartbeat)


class MessageType(enum.Enum):
    # pylint: disable=invalid-name
    Unknown = enum.auto()
    Ack = enum.auto()
    Heartbeat = enum.auto()
    HistoricalSpectrumDataRequest = enum.auto()
    HistoricalSpectrumDataResponse = enum.auto()
    LiveSpectrumDataRequest = enum.auto()
    LiveSpectrumDataResponse = enum.auto()
    Nack = enum.auto()
    MissionPlanDescriptor = enum.auto()
    MissionPlanDescriptorRequest = enum.auto()
    PolicyAssessmentRequest = enum.auto()
    PolicyAssessmentResponse = enum.auto()
    PolicyGenerationRequest = enum.auto()
    PolicyOptimizationRequest = enum.auto()
    RiskInformedPolicyResponse = enum.auto()
    SensorConfiguration = enum.auto()
    SensorNetworkDescriptor = enum.auto()
    SensorNetworkDescriptorRequest = enum.auto()
    SpectrumData = enum.auto()
    ActivePlansReport = enum.auto()
    ActivePlansRequest = enum.auto()
    HeartbeatReport = enum.auto()
    HeartbeatRequest = enum.auto()
    RadioEnvironmentDataReport = enum.auto()
    RadioEnvironmentDataRequest = enum.auto()
    RadioPlanReport = enum.auto()
    RadioPlanRequest = enum.auto()
    RadioPlanStatusReport = enum.auto()
    RadioPlanStatusRequest = enum.auto()
    RemovePlanReport = enum.auto()
    RemovePlanRequest = enum.auto()

    def __str__(self):
        return self.name


class ValidationResult:
    """Contains the result of message validation.

    Attributes
    ----------
    message_type : MessageType, default=MessageType.Unknown
        The type of the message if it could be determined

    is_valid : bool, default=False
        Whether validation succeeded or not

    error : str, default=None
        Any additional information about why validation failed

    error_code : NackReason, default=None
        An integer indicating the specific failure

    See Also
    --------
    - MessageType
    - MessageValidator
    - NackReason
    """

    def __init__(
        self,
        message_type=MessageType.Unknown,
        is_valid=False,
        error=None,
        error_code=None,
    ):
        self.message_type = message_type
        self.is_valid = is_valid
        self.error = error
        self.error_code = error_code

    def __bool__(self):
        """Return whether the result is valid or not

        Returns
        -------
        bool
            True means the result is valid.
            False means the result is not valid.
        """
        return self.is_valid

    def __str__(self):
        """Returns a string representation for the validation result"""
        result = {
            "valid": self.is_valid,
        }
        if self.is_valid:
            result["message_type"] = str(self.message_type)
        if not self.is_valid:
            result["error"] = str(self.error)
            result["error_code"] = str(self.error_code)
        return f"{result}"

    def __repr__(self):
        return "ValidationResult"


class MessageValidator:
    """Used for validating Tranche2 JSON Messages.

    This class expects all Tranche2 JSON messages to follow the MessageEnvelope
    schema.

    This class uses a factory to create a JSON Schema Validator object capable
    of verifying JSON messages follow the MessageEnvelope schema.

    This class returns a ValidationResult indicating the result of an
    individual message.

    See Also
    --------
    - ValidationResult
    - validation.JsonValidatorFactory
    """

    def __init__(self, validator_factory: validation.JsonValidatorFactory = None):
        if validator_factory is None:
            validator_factory = validation.JsonValidatorFactory(SCHEMA_DIR)
        self.validator = validator_factory.create_from_filename(
            os.path.join("common", "MessageEnvelope_MT.schema.json")
        )

    def validate(self, json_data):
        """Validate the given data

        Parameters
        ----------
        json_data : dict-like
            The data to validate

        Returns
        -------
        ValidationResult
            Indicates whether the message is valid or not
        """
        logger.debug("Decoding JSON data message type")
        # uncomment the following to prettify the json output in the terminal
        # comment out the following to remove block output
        logger.debug("%s", json.dumps(json_data))

        validation_result = ValidationResult()
        try:
            self.validator.validate(json_data)
            validation_result.is_valid = True
        except jsonschema.ValidationError as exc:
            error = f"Failed to validate JSON data.  Reason {exc}"
            logger.error(error)
            logger.exception(exc)
            validation_result.error = error
            validation_result.error_code = NackReason.JsonSchemaValidationFailed

        if validation_result:
            message_version = versioning.get_semantic_version(json_data["version"])
            if message_version < SCHEMA_MIN_VERSION:
                error = f"Receive message with version < {SCHEMA_MIN_VERSION}"
                logger.error(error)
                validation_result.error = error
                validation_result.is_valid = False
                validation_result.error_code = NackReason.JsonSchemaVersionMismatch
            elif message_version >= SCHEMA_MAX_VERSION:
                error = f"Receive message with version >= {SCHEMA_MAX_VERSION}"
                logger.error(error)
                validation_result.error = error
                validation_result.is_valid = False
                validation_result.error_code = NackReason.JsonSchemaVersionMismatch

        if validation_result:
            json_message_type = json_data.get("message", {}).get("type", "")
            try:
                validation_result.message_type = MessageType[json_message_type]
            except KeyError:
                error = f"Unexpected message type: {json_message_type}"
                logger.error(error)
                validation_result.error = error
                validation_result.message_type = MessageType.Unknown
                validation_result.is_valid = False
                validation_result.error_code = NackReason.UnsupportedOperation

        logger.debug("Validation result: %s", validation_result)
        return validation_result


class AngleQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for AngleQuantity.schema.json
    """

    # pylint: disable=invalid-name
    deg = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class AngleQuantity:
    """
    Defines a dataclass representing AngleQuantity.schema.json.
    """

    value: Union[float, int]
    unit: AngleQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", allowed_types=(int, float))
        check_object_field(self, "unit", AngleQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AngleQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = AngleQuantityUnit[data["unit"]]
        return AngleQuantity(value=value, unit=unit)


@dataclass(frozen=True)
class AckMt:
    """
    Defines a dataclass representing Ack_MT.schema.json.
    """

    request_message_id: UUID

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AckMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        return AckMt(request_message_id=request_message_id)


# TODO:
# This schema is undefined in tranche2 schemas and needs to be revisited when defined
@dataclass(frozen=True)
class BeamPattern:
    """
    Defines the dataclass for BeamPattern.schema.json
    """

    data: Dict[str, Any]

    def __post_init__(self):
        check_object_field(self, "data", dict)

    def to_dict(self):
        """
        Return Tranche2 compatible JSON.
        """
        return self.data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BeamPattern":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        return BeamPattern(data=data)


@dataclass(frozen=True)
class DayTimePeriod(TimeDurationInterface):
    """
    Defines a dataclass representing DayTimePeriod.schema.json.
    """

    start_day_time: dt
    end_day_time: dt

    def __post_init__(self):
        check_object_field(self, "start_day_time", dt)
        check_object_field(self, "end_day_time", dt)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "startDayTime": get_timestamp_as_str(self.start_day_time),
            "endDayTime": get_timestamp_as_str(self.end_day_time),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DayTimePeriod":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        start_day_time = get_timestamp_from_str(data["startDayTime"])
        end_day_time = get_timestamp_from_str(data["endDayTime"])
        return DayTimePeriod(start_day_time=start_day_time, end_day_time=end_day_time)

    @property
    def sec(self) -> float:
        """
        Return the duration represented by end_day_time - start_day_time in seconds.
        """
        return (self.end_day_time - self.start_day_time).total_seconds()

    @property
    def msec(self) -> float:
        """
        Return the duration represented by end_day_time - start_day_time in milliseconds.
        """
        return (self.end_day_time - self.start_day_time).total_seconds() * 1e3

    @property
    def usec(self) -> float:
        """
        Return the duration represented by end_day_time - start_day_time in microseconds.
        """
        return (self.end_day_time - self.start_day_time).total_seconds() * 1e6


class DistanceQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for DistanceQuantity.schema.json
    """

    # pylint: disable=invalid-name
    nm = enum.auto()
    mm = enum.auto()
    cm = enum.auto()
    m = enum.auto()
    km = enum.auto()
    inches = enum.auto()
    feet = enum.auto()
    yards = enum.auto()
    miles = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class DistanceQuantity:
    """
    Defines a dataclass representing DistanceQuantity.schema.json.
    """

    # factors relative to meters
    __scale_factors: ClassVar[Dict[DistanceQuantityUnit, float]] = {
        DistanceQuantityUnit.nm: 1e-9,
        DistanceQuantityUnit.mm: 1e-3,
        DistanceQuantityUnit.cm: 1e-2,
        DistanceQuantityUnit.m: 1,
        DistanceQuantityUnit.km: 1e3,
        DistanceQuantityUnit.inches: 0.0254,
        DistanceQuantityUnit.feet: 0.3048,
        DistanceQuantityUnit.yards: 0.9144,
        DistanceQuantityUnit.miles: 1609.344,
    }

    value: Union[int, float]
    unit: DistanceQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (int, float))
        check_object_field(self, "unit", DistanceQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DistanceQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = parse_enum_from_dict(data, "unit", DistanceQuantityUnit)
        return DistanceQuantity(value=value, unit=unit)

    def _convert_to(self, to_unit: DistanceQuantityUnit) -> float:
        from_factor = DistanceQuantity.__scale_factors[self.unit]
        to_factor = DistanceQuantity.__scale_factors[to_unit]
        return self.value * from_factor / to_factor

    @property
    def nm(self) -> float:
        """
        Convert value to nanometers
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.nm)

    @property
    def mm(self) -> float:
        """
        Convert value to millimeters
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.mm)

    @property
    def cm(self) -> float:
        """
        Convert value to centimeters
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.cm)

    @property
    def m(self) -> float:
        """
        Convert value to meters
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.m)

    @property
    def km(self) -> float:
        """
        Convert value to kilometers
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.km)

    @property
    def inches(self) -> float:
        """
        Convert value to inches
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.inches)

    @property
    def feet(self) -> float:
        """
        Convert value to feet
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.feet)

    @property
    def yards(self) -> float:
        """
        Convert value to yards
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.yards)

    @property
    def miles(self) -> float:
        """
        Convert value to miles
        """
        return self._convert_to(to_unit=DistanceQuantityUnit.miles)


class FractionQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for FractionQuantity.schema.json
    """

    # pylint: disable=invalid-name
    fraction = enum.auto()
    percent = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class FractionQuantity:
    """
    Defines a dataclass representing FractionQuantity.schema.json.
    """

    __BOUNDS_CHECK: ClassVar[dict] = {
        FractionQuantityUnit.fraction: {"minimum": 0, "maximum": 1},
        FractionQuantityUnit.percent: {"minimum": 0, "maximum": 100},
    }

    value: Union[int, float]
    unit: FractionQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", allowed_types=(int, float))
        check_object_field(self, "unit", FractionQuantityUnit)
        bounds_kwargs = FractionQuantity.__BOUNDS_CHECK[self.unit]
        check_inclusive_bounds("value", self.value, **bounds_kwargs)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FractionQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = FractionQuantityUnit[data["unit"]]
        return FractionQuantity(value=value, unit=unit)


class FrequencyQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for FrequencyQuantity.schema.json.
    """

    # pylint: disable=invalid-name
    Hz = enum.auto()
    kHz = enum.auto()
    MHz = enum.auto()
    GHz = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class FrequencyQuantity:
    """
    Defines a dataclass representing FrequencyQuantity.schema.json.
    """

    # pylint: disable=invalid-name

    __scale_factors: ClassVar[Dict[FrequencyQuantityUnit, float]] = {
        FrequencyQuantityUnit.Hz: 1,
        FrequencyQuantityUnit.kHz: 1e3,
        FrequencyQuantityUnit.MHz: 1e6,
        FrequencyQuantityUnit.GHz: 1e9,
    }

    value: Union[int, float]
    unit: FrequencyQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (int, float))
        check_object_field(self, "unit", FrequencyQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        value_unit = data["unit"]
        try:
            unit = FrequencyQuantityUnit[value_unit]
        except KeyError as exc:
            names = [str(name) for name in FrequencyQuantityUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc
        return FrequencyQuantity(value=value, unit=unit)

    def _convert_unit(self, to_unit: FrequencyQuantityUnit) -> float:
        from_factor = FrequencyQuantity.__scale_factors[self.unit]
        to_factor = FrequencyQuantity.__scale_factors[to_unit]
        return self.value * from_factor / to_factor

    @property
    def Hz(self) -> float:
        """
        Return the frequency value in Hz
        """
        return self._convert_unit(to_unit=FrequencyQuantityUnit.Hz)

    @property
    def kHz(self) -> float:
        """
        Return the frequency value in kHz
        """
        return self._convert_unit(to_unit=FrequencyQuantityUnit.kHz)

    @property
    def MHz(self) -> float:
        """
        Return the frequency value in MHz
        """
        return self._convert_unit(to_unit=FrequencyQuantityUnit.MHz)

    @property
    def GHz(self) -> float:
        """
        Return the frequency value in Hz
        """
        return self._convert_unit(to_unit=FrequencyQuantityUnit.GHz)


@dataclass(frozen=True)
class FrequencyBand:
    """
    Defines a dataclass representing FrequencyBand.schema.json.
    """

    start_freq: FrequencyQuantity
    end_freq: FrequencyQuantity

    def __post_init__(self):
        check_object_field(self, "start_freq", FrequencyQuantity)
        check_object_field(self, "end_freq", FrequencyQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "startFreq": self.start_freq.to_dict(),
            "endFreq": self.end_freq.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyBand":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        start_freq = FrequencyQuantity.from_dict(data["startFreq"])
        end_freq = FrequencyQuantity.from_dict(data["endFreq"])
        return FrequencyBand(start_freq=start_freq, end_freq=end_freq)


class GainQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for GainQuantity.schema.json
    """

    # pylint: disable=invalid-name
    dB = enum.auto()
    dBi = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class GainQuantity:
    """
    Defines a dataclass representing GainQuantity.schema.json.
    """

    value: Union[int, float]
    unit: GainQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (int, float))
        check_object_field(self, "unit", GainQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GainQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = GainQuantityUnit[data["unit"]]
        return GainQuantity(value=value, unit=unit)


@dataclass(frozen=True)
class GainFreqQuantity:
    """
    Defines a dataclass representing GainFreqQuantity.schema.json.
    """

    gain: GainQuantity
    frequency: FrequencyQuantity

    def __post_init__(self):
        check_object_field(self, "gain", GainQuantity)
        check_object_field(self, "frequency", FrequencyQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "gain": self.gain.to_dict(),
            "frequency": self.frequency.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GainFreqQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        gain = GainQuantity.from_dict(data["gain"])
        frequency = FrequencyQuantity.from_dict(data["frequency"])
        return GainFreqQuantity(gain=gain, frequency=frequency)


@dataclass(frozen=True)
class GeoJsonPoint:
    """
    Defines a dataclass representing a GeoJSON Point.
    """

    coordinates: np.ndarray

    def __post_init__(self):
        check_object_field(self, "coordinates", np.ndarray)
        # verify coordinates shape is (x,)
        if not np.issubdtype(self.coordinates.dtype, np.number):
            raise ValueError("coordinates is not numeric")
        if len(self.coordinates.shape) != 1:
            raise ValueError("coordinates must be a 1D array")
        if self.coordinates.shape[0] < 2:
            raise ValueError("coordinates must have at least two elements")

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "type": "Point",
            "coordinates": self.coordinates.tolist(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoJsonPoint":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        data_type = data["type"]
        if data_type != "Point":
            raise ValueError(f"Attempting to convert non-Point {data_type} to Point")
        coordinates = np.asarray(data["coordinates"])
        return GeoJsonPoint(coordinates=coordinates)


@dataclass(frozen=True)
class GeoJsonPolygon:
    """
    Defines a dataclass representing a GeoJSON Polygon.
    """

    coordinates: List[np.ndarray]

    def __post_init__(self):
        # verify coordinates shape is a list of 2D arrays
        check_object_list(self, "coordinates", np.ndarray)
        for idx, arr in enumerate(self.coordinates):
            if not np.issubdtype(arr.dtype, np.number):
                raise ValueError(f"coordinates[{idx}] is not numeric")
            if len(arr.shape) != 2:
                raise ValueError(f"coordinates[{idx}] must be a 2D array")
            if arr.shape[0] < 4:
                raise ValueError(
                    f"coordinates[{idx}].shape[0] must have at least four elements"
                )
            if arr.shape[1] < 2:
                raise ValueError(
                    f"coordinates[{idx}].shape[1] must have at least two elements"
                )
            # verify ring constraint
            if (arr[0, :] != arr[-1, :]).all():
                raise ValueError(f"coordinates[{idx}] is not a closed linear ring")

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "type": "Polygon",
            "coordinates": [arr.tolist() for arr in self.coordinates],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoJsonPolygon":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        data_type = data["type"]
        if data_type != "Polygon":
            raise ValueError(
                f"Attempting to convert non-Polygon {data_type} to Polygon"
            )
        coordinates = [np.asarray(arr) for arr in data["coordinates"]]
        return GeoJsonPolygon(coordinates=coordinates)


@dataclass(frozen=True)
class GeoJsonFeature:
    """
    Defines a dataclass representing a GeoJSON Feature.
    """

    __GEOMETRY_CLASS_MAP: ClassVar[dict] = {
        "Point": GeoJsonPoint,
        "Polygon": GeoJsonPolygon,
    }
    __GEOMETRY_ALLOWED_TYPES: ClassVar[tuple] = (GeoJsonPoint, GeoJsonPolygon)

    geometry: Union[GeoJsonPoint, GeoJsonPolygon]
    properties: Union[None, Dict] = None

    def __post_init__(self):
        check_object_field(self, "geometry", GeoJsonFeature.__GEOMETRY_ALLOWED_TYPES)
        check_optional_type(self, "properties", dict)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "type": "Feature",
            "properties": self.properties,
            "geometry": self.geometry.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoJsonFeature":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        data_type = data["type"]
        if data_type != "Feature":
            raise ValueError(
                f"Attempting to convert non-Feature {data_type} to Feature"
            )
        geometry_data = data["geometry"]
        geometry_type = geometry_data["type"]
        geometry_class: Union[GeoJsonPoint, GeoJsonPolygon] = cls.__GEOMETRY_CLASS_MAP[
            geometry_type
        ]
        geometry = geometry_class.from_dict(geometry_data)
        properties = data["properties"]
        return GeoJsonFeature(properties=properties, geometry=geometry)


@dataclass(frozen=True)
class GeoSpatialInfoCircle:
    """
    Defines a dataclass representing GeoSpatialInfo.schema.json's circle.
    """

    feature: GeoJsonFeature
    altitude: DistanceQuantity
    radius: DistanceQuantity

    def __post_init__(self):
        check_object_field(self, "feature", GeoJsonFeature)
        check_object_field(self.feature, "geometry", GeoJsonPoint)
        check_object_field(self, "altitude", DistanceQuantity)
        check_object_field(self, "radius", DistanceQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "shape": str(GeoSpatialInfoShape.circle),
            "feature": self.feature.to_dict(),
            "altitude": self.altitude.to_dict(),
            "radius": self.radius.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoSpatialInfoCircle":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        shape = data["shape"]
        if shape != str(GeoSpatialInfoShape.circle):
            raise ValueError(
                f"Attempting to convert non-circle {shape} to {GeoSpatialInfoShape.circle}"
            )
        feature = GeoJsonFeature.from_dict(data["feature"])
        altitude = DistanceQuantity.from_dict(data["altitude"])
        radius = DistanceQuantity.from_dict(data["radius"])
        return GeoSpatialInfoCircle(feature=feature, altitude=altitude, radius=radius)


@dataclass(frozen=True)
class GeoSpatialInfoPolygon:
    """
    Defines a dataclass representing GeoSpatialInfo.schema.json's polygon.
    """

    feature: GeoJsonFeature
    altitude: DistanceQuantity

    def __post_init__(self):
        check_object_field(self, "feature", GeoJsonFeature)
        check_object_field(self.feature, "geometry", GeoJsonPolygon)
        check_object_field(self, "altitude", DistanceQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "shape": str(GeoSpatialInfoShape.polygon),
            "feature": self.feature.to_dict(),
            "altitude": self.altitude.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoSpatialInfoPolygon":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        shape = data["shape"]
        if shape != str(GeoSpatialInfoShape.polygon):
            raise ValueError(
                f"Attempting to convert non-polygon {shape} to {str(GeoSpatialInfoShape.polygon)}"
            )
        feature = GeoJsonFeature.from_dict(data["feature"])
        altitude = DistanceQuantity.from_dict(data["altitude"])
        return GeoSpatialInfoPolygon(feature=feature, altitude=altitude)


class GeoSpatialInfoShape(enum.IntEnum):
    """
    Defines valid shapes for GeoSpatialInfo.schema.json.
    """

    # pylint: disable=invalid-name
    circle = enum.auto()
    polygon = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class GeoSpatialInfo:
    """
    Defines a dataclass representing a GeoSpatialInfo.schema.json.
    """

    __SHAPE_TYPE_CLASS_MAP: ClassVar[dict] = {
        str(GeoSpatialInfoShape.circle): GeoSpatialInfoCircle,
        str(GeoSpatialInfoShape.polygon): GeoSpatialInfoPolygon,
    }
    __ALLOWED_TYPES: ClassVar[tuple] = (GeoSpatialInfoCircle, GeoSpatialInfoPolygon)

    shape: Union[GeoSpatialInfoCircle, GeoSpatialInfoPolygon]

    @property
    def shape_type(self) -> GeoSpatialInfoShape:
        """
        Return the type of the GeoSpatialInfo shape.
        """
        if isinstance(self.shape, GeoSpatialInfoCircle):
            return GeoSpatialInfoShape.circle
        elif isinstance(self.shape, GeoSpatialInfoPolygon):
            return GeoSpatialInfoShape.polygon
        return None

    def __post_init__(self):
        check_object_field(self, "shape", GeoSpatialInfo.__ALLOWED_TYPES)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return self.shape.to_dict()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoSpatialInfo":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        shape_type = data["shape"]
        shape_class: Union[
            GeoSpatialInfoCircle, GeoSpatialInfoPolygon
        ] = cls.__SHAPE_TYPE_CLASS_MAP[shape_type]
        shape = shape_class.from_dict(data)
        return GeoSpatialInfo(shape=shape)


@dataclass(frozen=True)
class HeartbeatMt:
    """
    Defines a dataclass representing Heartbeat_MT.schema.json.
    """

    instance_id: UUID
    timeout: Union[dt, None] = None

    def __post_init__(self):
        check_object_field(self, "instance_id", UUID)
        check_optional_type(self, "timeout", dt)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "instanceId": str(self.instance_id),
        }
        if self.timeout is not None:
            data["timeout"] = get_timestamp_as_str(self.timeout)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HeartbeatMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        instance_id = UUID(data["instanceId"])
        timeout = None
        if "timeout" in data:
            timeout = get_timestamp_from_str(data["timeout"])
        return HeartbeatMt(instance_id=instance_id, timeout=timeout)

    @classmethod
    def from_status(
        cls, status: Status, timeout_multiplier: float = 1.5, now: dt = None
    ) -> "HeartbeatMt":
        """
        Convert a :py:class:`Status` message into a HeartbeatMt message.

        Parameters
        ----------
        status : :py:class`risa.messages.Status`
            The status message to convert

        timeout_multiplier : float, default=1.5
            The amount to multiply status.reporting_interval by to determine the timeout

        now : datetime, default=None
            The current timestamp to base the timeout on.  If ``None``, then
            use ``datetime.now()``.

        Returns
        -------
        HeartbeatMt
            instance_id is set based on ``status.name``
            timeout is set to ``now + status.reporting_interval * timeout_multiplier``
        """
        instance_id = UUID(uuid5.get_tranche2_uuid5("risa-origin", status.name))
        if now is None:
            now = dt.now()
        delta = timedelta(seconds=status.reporting_interval) * timeout_multiplier
        timeout = now + delta
        return HeartbeatMt(instance_id=instance_id, timeout=timeout)


class SpectrumDbEntryTupleType(enum.IntEnum):
    """
    Defines valid data types for HistoricalSpectrumDataRequest_MT.schema.json
    and HistoricalSpectrumDataResponse_MT.schema.json
    """

    # pylint: disable=invalid-name
    FreqResponseRecord = enum.auto()
    IQResponseRecord = enum.auto()
    TDOAResponseRecord = enum.auto()
    LOBResponseRecord = enum.auto()
    ClassificationResponseRecord = enum.auto()
    Spectrogram = enum.auto()
    Heatmap = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class SpectrumDbEntryTuple:
    """
    Defines a dataclass representing SpectrumDBEntryTuple.schema.json.
    """

    entry_id: UUID
    entry_type: SpectrumDbEntryTupleType

    def __post_init__(self):
        check_object_field(self, "entry_id", UUID)
        check_object_field(self, "entry_type", SpectrumDbEntryTupleType)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "entryId": str(self.entry_id),
            "type": str(self.entry_type),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SpectrumDbEntryTuple":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        entry_id = UUID(data["entryId"])
        entry_type = SpectrumDbEntryTupleType[data["type"]]
        return SpectrumDbEntryTuple(entry_id=entry_id, entry_type=entry_type)


class PowerQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for PowerQuantity.schema.json
    """

    # pylint: disable=invalid-name
    W = enum.auto()
    mW = enum.auto()
    dBm = enum.auto()
    dB = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class PowerQuantity:
    """
    Defines a dataclass representing PowerQuantity.schema.json.
    """

    # pylint: disable=invalid-name

    # scale factors relative to W
    __scale_factors: ClassVar[dict] = {
        PowerQuantityUnit.W: 1,
        PowerQuantityUnit.mW: 1e-3,
    }

    value: Union[int, float]
    unit: PowerQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", allowed_types=(int, float))
        check_object_field(self, "unit", PowerQuantityUnit)

    def to_unit(self, unit: PowerQuantityUnit) -> "PowerQuantity":
        """
        Return power value converted to other units

        Raises
        ------
        ValueError
            If self.unit == PowerQuantityUnit.dB
        """
        converted_power = self._convert_value(unit)
        return PowerQuantity(value=converted_power, unit=unit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PowerQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = PowerQuantityUnit[data["unit"]]
        return PowerQuantity(value=value, unit=unit)

    def _convert_value(self, to_unit: PowerQuantityUnit) -> float:
        """
        Raises
        ------
        ValueError
            self.unit == PowerQuantityUnit.dB
        """
        if self.unit == PowerQuantityUnit.dB:
            raise ValueError("Cannot convert relative power")

        from_power_value = self.value
        if self.unit == PowerQuantityUnit.dBm:
            # convert power quantity to W
            from_power_value_w = util.dbm_to_watt(from_power_value)
        else:
            # convert power to W using scale factor
            from_factor = PowerQuantity.__scale_factors[self.unit]
            from_power_value_w = from_power_value * from_factor

        # check to see if we are converting to dBm
        if to_unit == PowerQuantityUnit.dBm:
            power = util.watt_to_dbm(from_power_value_w)
        else:
            to_factor = PowerQuantity.__scale_factors[to_unit]
            power = from_power_value_w / to_factor

        return power

    @property
    def dBm(self) -> float:
        """
        Convert power value to dBm

        Raises
        ------
        ValueError
            If unit is dB
        """
        return self._convert_value(PowerQuantityUnit.dBm)

    @property
    def W(self) -> float:
        """
        Convert power value to W

        Raises
        ------
        ValueError
            If unit is dB
        """
        return self._convert_value(PowerQuantityUnit.W)

    @property
    def mW(self) -> float:
        """
        Convert power value to mW

        Raises
        ------
        ValueError
            If unit is dB
        """
        return self._convert_value(PowerQuantityUnit.mW)


class EqualityConstraint(enum.IntEnum):
    """
    Defines valid enumerations for TransmissionTypeRule.schema.json
    """

    # pylint: disable=invalid-name
    lessThanOrEqual = enum.auto()
    equal = enum.auto()
    greaterThanOrEqual = enum.auto()

    def __str__(self):
        return _EqualityConstraint_STR_REPLACEMENT_MAP[self.value]

    @classmethod
    def from_string(cls, item: str):
        """
        Convert a string into an EqualityConstraint.

        Parameters
        ----------
        item : str
            The string to look up

        Raises
        ------
        KeyError
            No such item can be found
        """
        return _EqualityConstraint_STR_LOOKUP_MAP[item]


# have to define these at the module level, otherwise run into
# the following error with the enum metaclass
# /usr/lib/python3.8/enum.py:243: in __new__
#     enum_member = __new__(enum_class, *args)
# E   TypeError: int() argument must be a string, a bytes-like object or a number, not 'dict'
_EqualityConstraint_STR_REPLACEMENT_MAP = {
    EqualityConstraint.lessThanOrEqual: "<=",
    EqualityConstraint.equal: "=",
    EqualityConstraint.greaterThanOrEqual: ">=",
}
_EqualityConstraint_STR_LOOKUP_MAP = {
    value: key for key, value in _EqualityConstraint_STR_REPLACEMENT_MAP.items()
}


@dataclass(frozen=True)
class TransmissionTypeRule:
    """
    Defines a dataclass representing TransmissionTypeRule.schema.json.
    """

    # TODO... should rule_id / transmissionTypeRuleId get removed from the T2 schemas?
    rule_id: UUID
    power_limit: PowerQuantity
    equality_constraint: EqualityConstraint

    def __post_init__(self):
        check_object_field(self, "rule_id", UUID)
        check_object_field(self, "power_limit", PowerQuantity)
        check_object_field(self, "equality_constraint", EqualityConstraint)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "transmissionTypeRuleId": str(self.rule_id),
            "powerLimit": self.power_limit.to_dict(),
            "equalityConstraint": str(self.equality_constraint),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TransmissionTypeRule":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        rule_id = UUID(data["transmissionTypeRuleId"])
        power_limit = PowerQuantity.from_dict(data["powerLimit"])
        equality_constraint = EqualityConstraint.from_string(data["equalityConstraint"])
        return TransmissionTypeRule(
            rule_id=rule_id,
            power_limit=power_limit,
            equality_constraint=equality_constraint,
        )


@dataclass(frozen=True)
class HistoricalSpectrumDataRequestMt:
    """
    Defines a dataclass representing HistoricalSpectrumDataRequest_MT.schema.json.
    """

    data_type: List[SpectrumDbEntryTupleType]
    request_period: DayTimePeriod
    request_band: FrequencyBand
    region: GeoSpatialInfo

    def __post_init__(self):
        check_object_list(self, "data_type", SpectrumDbEntryTupleType, allow_empty=True)
        check_object_field(self, "request_period", DayTimePeriod)
        check_object_field(self, "request_band", FrequencyBand)
        check_object_field(self, "region", GeoSpatialInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "dataType": [str(item) for item in self.data_type],
            "requestPeriod": self.request_period.to_dict(),
            "requestBand": self.request_band.to_dict(),
            "region": self.region.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HistoricalSpectrumDataRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        data_type = [SpectrumDbEntryTupleType[item] for item in data["dataType"]]
        request_period = DayTimePeriod.from_dict(data["requestPeriod"])
        request_band = FrequencyBand.from_dict(data["requestBand"])
        region = GeoSpatialInfo.from_dict(data["region"])
        return HistoricalSpectrumDataRequestMt(
            data_type=data_type,
            request_period=request_period,
            request_band=request_band,
            region=region,
        )


@dataclass(frozen=True)
class HistoricalSpectrumDataResponseMt:
    """
    Defines a dataclass representing HistoricalSpectrumDataResponseMt.schema.json.
    """

    request_message_id: UUID
    results: List[SpectrumDbEntryTuple]

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_list(self, "results", SpectrumDbEntryTuple, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "results": [entry.to_dict() for entry in self.results],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HistoricalSpectrumDataResponseMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        results = [SpectrumDbEntryTuple.from_dict(item) for item in data["results"]]
        return HistoricalSpectrumDataResponseMt(
            request_message_id=request_message_id, results=results
        )


class TimeQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for TimeQuantity.schema.json
    """

    # pylint: disable=invalid-name
    sec = enum.auto()
    msec = enum.auto()
    usec = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class TimeQuantity(TimeDurationInterface):
    """
    Defines a dataclass representing TimeQuantity.schema.json.
    """

    __scale_factors: ClassVar[Dict[TimeQuantityUnit, float]] = {
        TimeQuantityUnit.sec: 1,
        TimeQuantityUnit.msec: 1e-3,
        TimeQuantityUnit.usec: 1e-6,
    }

    value: Union[float, int]
    unit: TimeQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (float, int))
        check_object_field(self, "unit", TimeQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TimeQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = TimeQuantityUnit[data["unit"]]
        return TimeQuantity(value=value, unit=unit)

    def _convert_value(self, to_unit: TimeQuantityUnit) -> float:
        from_factor = TimeQuantity.__scale_factors[self.unit]
        to_factor = TimeQuantity.__scale_factors[to_unit]
        return self.value * from_factor / to_factor

    @property
    def sec(self) -> float:
        """
        Return time quantity value in seconds.
        """
        return self._convert_value(TimeQuantityUnit.sec)

    @property
    def msec(self) -> float:
        """
        Return time quantity value in seconds.
        """
        return self._convert_value(TimeQuantityUnit.msec)

    @property
    def usec(self) -> float:
        """
        Return time quantity value in seconds.
        """
        return self._convert_value(TimeQuantityUnit.usec)


@dataclass(frozen=True)
class FrequencyScanRequest:
    """
    Defines a dataclass representing FrequencyScanRequest.schema.json.
    """

    task_id: UUID
    frequency_band: FrequencyBand
    task_duration_seconds: Union[float, int]
    gain_setting: Union[float, int]
    start_time: dt
    response_interval_seconds: Union[float, int, None] = None
    method_type: Union[str, None] = None
    two_channel_flag: Union[bool, None] = None
    num_fft_bins: Union[int, None] = None
    classification_flag: Union[bool, None] = None

    def __post_init__(self):
        check_object_field(self, "task_id", UUID)
        check_object_field(self, "frequency_band", FrequencyBand)
        check_object_field(self, "task_duration_seconds", allowed_types=(float, int))
        check_object_field(self, "gain_setting", allowed_types=(float, int))
        check_object_field(self, "start_time", dt)
        check_optional_type(
            self, "response_interval_seconds", allowed_types=(float, int)
        )
        check_optional_type(self, "method_type", str)
        check_optional_type(self, "two_channel_flag", bool)
        check_optional_type(self, "num_fft_bins", int)
        check_optional_type(self, "classification_flag", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "taskId": str(self.task_id),
            "frequencyBand": self.frequency_band.to_dict(),
            "taskDurationSeconds": self.task_duration_seconds,
            "gainSetting": self.gain_setting,
            "startTime": get_timestamp_as_str(self.start_time),
        }
        if self.response_interval_seconds is not None:
            data["responseIntervalSeconds"] = self.response_interval_seconds
        if self.method_type is not None:
            data["methodType"] = self.method_type
        if self.two_channel_flag is not None:
            data["twoChannelFlag"] = self.two_channel_flag
        if self.num_fft_bins is not None:
            data["numFftBins"] = self.num_fft_bins
        if self.classification_flag is not None:
            data["classificationFlag"] = self.classification_flag
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyScanRequest":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        task_id = UUID(data["taskId"])
        frequency_band = FrequencyBand.from_dict(data["frequencyBand"])
        task_duration_seconds = data["taskDurationSeconds"]
        gain_setting = data["gainSetting"]
        start_time = get_timestamp_from_str(data["startTime"])
        response_interval_seconds = parse_optional(data, "responseIntervalSeconds")
        method_type = parse_optional(data, "methodType")
        two_channel_flag = parse_optional(data, "twoChannelFlag")
        num_fft_bins = parse_optional(data, "numFftBins")
        classification_flag = parse_optional(data, "classificationFlag")
        return FrequencyScanRequest(
            task_id=task_id,
            frequency_band=frequency_band,
            task_duration_seconds=task_duration_seconds,
            gain_setting=gain_setting,
            start_time=start_time,
            response_interval_seconds=response_interval_seconds,
            method_type=method_type,
            two_channel_flag=two_channel_flag,
            num_fft_bins=num_fft_bins,
            classification_flag=classification_flag,
        )


@dataclass(frozen=True)
class IqAcquisitionRequest:
    """
    Defines a dataclass representing IQAcquisitionRequest.schema.json.
    """

    task_id: UUID
    tdoa_flag: bool
    min_frequency: FrequencyQuantity
    max_frequency: FrequencyQuantity
    response_interval_seconds: Union[float, int]
    task_duration_seconds: Union[float, int]
    gain_setting: Union[float, int]
    method_type: str
    two_channel_flag: bool
    num_samples: int
    start_time: dt

    def __post_init__(self):
        check_object_field(self, "task_id", UUID)
        check_object_field(self, "tdoa_flag", bool)
        check_object_field(self, "min_frequency", FrequencyQuantity)
        check_object_field(self, "max_frequency", FrequencyQuantity)
        check_object_field(self, "response_interval_seconds", (float, int))
        check_object_field(self, "task_duration_seconds", (float, int))
        check_object_field(self, "gain_setting", (float, int))
        check_object_field(self, "method_type", str)
        check_object_field(self, "two_channel_flag", bool)
        check_object_field(self, "num_samples", int)
        check_object_field(self, "start_time", dt)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "taskId": str(self.task_id),
            "tdoaFlag": self.tdoa_flag,
            "minFrequency": self.min_frequency.to_dict(),
            "maxFrequency": self.max_frequency.to_dict(),
            "responseIntervalSeconds": self.response_interval_seconds,
            "taskDurationSeconds": self.task_duration_seconds,
            "gainSetting": self.gain_setting,
            "methodType": self.method_type,
            "twoChannelFlag": self.two_channel_flag,
            "numSamples": self.num_samples,
            "startTime": get_timestamp_as_str(self.start_time),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IqAcquisitionRequest":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        task_id = UUID(data["taskId"])
        tdoa_flag = data["tdoaFlag"]
        min_frequency = FrequencyQuantity.from_dict(data["minFrequency"])
        max_frequency = FrequencyQuantity.from_dict(data["maxFrequency"])
        response_interval_seconds = data["responseIntervalSeconds"]
        task_duration_seconds = data["taskDurationSeconds"]
        gain_setting = data["gainSetting"]
        method_type = data["methodType"]
        two_channel_flag = data["twoChannelFlag"]
        num_samples = data["numSamples"]
        start_time = get_timestamp_from_str(data["startTime"])
        return IqAcquisitionRequest(
            task_id=task_id,
            tdoa_flag=tdoa_flag,
            min_frequency=min_frequency,
            max_frequency=max_frequency,
            response_interval_seconds=response_interval_seconds,
            task_duration_seconds=task_duration_seconds,
            gain_setting=gain_setting,
            method_type=method_type,
            two_channel_flag=two_channel_flag,
            num_samples=num_samples,
            start_time=start_time,
        )


class SpectrumTaskType(enum.IntEnum):
    """
    Defines valid data types for SpectrumTask.schema.json
    """

    # pylint: disable=invalid-name
    FrequencyScanRequest = enum.auto()
    IQAcquisitionRequest = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class SpectrumTask:
    """
    Defines a dataclass representing SpectrumTask.schema.json.
    """

    __REQUEST_CLASS_TYPE_MAP: ClassVar[dict] = {
        SpectrumTaskType.FrequencyScanRequest: FrequencyScanRequest,
        SpectrumTaskType.IQAcquisitionRequest: IqAcquisitionRequest,
    }

    request: Union[FrequencyScanRequest, IqAcquisitionRequest]

    def __post_init__(self):
        check_object_field(
            self, "request", allowed_types=(FrequencyScanRequest, IqAcquisitionRequest)
        )

    @property
    def request_type(self) -> SpectrumTaskType:
        """
        Return the type of request for the task.

        Returns
        -------
        SpectrumTaskType
        """
        if isinstance(self.request, FrequencyScanRequest):
            return SpectrumTaskType.FrequencyScanRequest
        return SpectrumTaskType.IQAcquisitionRequest

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "type": str(self.request_type),
            "request": self.request.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SpectrumTask":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_type = SpectrumTaskType[data["type"]]
        request_class = cls.__REQUEST_CLASS_TYPE_MAP[request_type]
        request = request_class.from_dict(data["request"])
        return SpectrumTask(request=request)


@dataclass(frozen=True)
class LiveSpectrumDataRequestMt:
    """
    Defines a dataclass representing LiveSpectrumDataRequest_MT.schema.json.
    """

    task: SpectrumTask
    region: GeoSpatialInfo
    min_sensors: Union[int, None] = None

    def __post_init__(self):
        check_object_field(self, "task", SpectrumTask)
        check_object_field(self, "region", GeoSpatialInfo)
        check_optional_type(self, "min_sensors", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "task": self.task.to_dict(),
            "region": self.region.to_dict(),
        }
        if self.min_sensors is not None:
            data["minSensors"] = self.min_sensors
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LiveSpectrumDataRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        task = SpectrumTask.from_dict(data["task"])
        region = GeoSpatialInfo.from_dict(data["region"])
        min_sensors = data.get("minSensors", None)
        return LiveSpectrumDataRequestMt(
            task=task, region=region, min_sensors=min_sensors
        )


@dataclass(frozen=True)
class LiveSpectrumDataResponseMt:
    """
    Defines a dataclass representing LiveSpectrumDataResponse_MT.schema.json.
    """

    request_message_id: UUID
    assigned_sensors: List[UUID]

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_list(self, "assigned_sensors", UUID, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "assignedSensors": [str(sensor) for sensor in self.assigned_sensors],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LiveSpectrumDataResponseMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        assigned_sensors = [UUID(item) for item in data["assignedSensors"]]
        return LiveSpectrumDataResponseMt(
            request_message_id=request_message_id, assigned_sensors=assigned_sensors
        )


@dataclass(frozen=True)
class MissionPlanDescriptorRequestByTimePeriod:
    """
    Defines a dataclass representing an inner schema of
    MissionPlanDescriptorRequest_MT.schema.json
    """

    mission_request_period: DayTimePeriod

    def __post_init__(self):
        check_object_field(self, "mission_request_period", DayTimePeriod)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"missionRequestPeriod": self.mission_request_period.to_dict()}

    @classmethod
    def from_dict(
        cls, data: Dict[str, Any]
    ) -> "MissionPlanDescriptorRequestByTimePeriod":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_request_period = DayTimePeriod.from_dict(data["missionRequestPeriod"])
        return MissionPlanDescriptorRequestByTimePeriod(
            mission_request_period=mission_request_period
        )


@dataclass(frozen=True)
class MissionPlanDescriptorRequestByMissionId:
    """
    Defines a dataclass representing an inner schema of
    MissionPlanDescriptorRequest_MT.schema.json
    """

    mission_id_list: List[UUID]

    def __post_init__(self):
        check_object_list(self, "mission_id_list", UUID, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"missionIdList": [str(item) for item in self.mission_id_list]}

    @classmethod
    def from_dict(
        cls, data: Dict[str, Any]
    ) -> "MissionPlanDescriptorRequestByMissionId":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_id_list = [UUID(item) for item in data["missionIdList"]]
        return MissionPlanDescriptorRequestByMissionId(mission_id_list=mission_id_list)


@dataclass(frozen=True)
class MissionPlanDescriptorRequestByNetworkId:
    """
    Defines a dataclass representing an inner schema of
    MissionPlanDescriptorRequest_MT.schema.json
    """

    network_id_list: List[UUID]

    def __post_init__(self):
        check_object_list(self, "network_id_list", UUID, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"networkIdList": [str(item) for item in self.network_id_list]}

    @classmethod
    def from_dict(
        cls, data: Dict[str, Any]
    ) -> "MissionPlanDescriptorRequestByNetworkId":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        network_id_list = [UUID(item) for item in data["networkIdList"]]
        return MissionPlanDescriptorRequestByNetworkId(network_id_list=network_id_list)


@dataclass(frozen=True)
class MissionPlanDescriptorRequestMt:
    """
    Defines a dataclass representing MissionPlanDescriptorRequest_MT.schema.json
    """

    __INNER_CLASSES: ClassVar[
        Dict[
            str,
            Union[
                MissionPlanDescriptorRequestByTimePeriod,
                MissionPlanDescriptorRequestByMissionId,
                MissionPlanDescriptorRequestByNetworkId,
            ],
        ]
    ] = {
        "missionRequestPeriod": MissionPlanDescriptorRequestByTimePeriod,
        "missionIdList": MissionPlanDescriptorRequestByMissionId,
        "networkIdList": MissionPlanDescriptorRequestByNetworkId,
    }

    request: Union[
        MissionPlanDescriptorRequestByTimePeriod,
        MissionPlanDescriptorRequestByMissionId,
        MissionPlanDescriptorRequestByNetworkId,
    ]

    def __post_init__(self):
        check_object_field(
            self,
            "request",
            (
                MissionPlanDescriptorRequestByTimePeriod,
                MissionPlanDescriptorRequestByMissionId,
                MissionPlanDescriptorRequestByNetworkId,
            ),
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return self.request.to_dict()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MissionPlanDescriptorRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        inner_class = None
        for (
            field,
            field_class,
        ) in MissionPlanDescriptorRequestMt.__INNER_CLASSES.items():
            if field in data:
                inner_class = field_class
                break
        if inner_class is None:
            raise ValueError("Invalid MissionPlanDescriptorRequestMt")
        request = inner_class.from_dict(data)
        return MissionPlanDescriptorRequestMt(request=request)


@dataclass(frozen=True)
class NackMt:
    """
    Defines a dataclass representing Nack_MT.schema.json.
    """

    error_code: int
    request_message_id: Union[UUID, None] = None

    def __post_init__(self):
        check_object_field(self, "error_code", int)
        check_optional_type(self, "request_message_id", UUID)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "errorCode": self.error_code,
        }
        if self.request_message_id is not None:
            data["requestMessageId"] = str(self.request_message_id)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NackMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        error_code = data["errorCode"]
        request_message_id = parse_optional(data, "requestMessageId")
        if request_message_id is not None:
            request_message_id = UUID(request_message_id)
        return NackMt(error_code=error_code, request_message_id=request_message_id)


@dataclass(frozen=True)
class NetworkGuidance:
    """
    Defines a dataclass representing NetworkGuidance.schema.json.
    """

    network_id: UUID
    primary_frequency_band: FrequencyBand
    duty_cycle_tolerance_threshold: Union[float, int]
    duty_cycle_tolerance_goal: Union[float, int]
    interference_tolerance_threshold: Union[GainQuantity, None] = None
    interference_tolerance_goal: Union[GainQuantity, None] = None
    packet_loss_rate_tolerance_threshold: Union[float, int, None] = None
    packet_loss_rate_tolerance_goal: Union[float, int, None] = None
    network_priority: Union[int, None] = None
    incumbent_id: Union[int, float, None] = None

    def __post_init__(self):
        check_object_field(self, "network_id", UUID)
        check_object_field(self, "primary_frequency_band", FrequencyBand)
        check_inclusive_bounds(
            "duty_cycle_tolerance_threshold", self.duty_cycle_tolerance_threshold
        )
        check_inclusive_bounds(
            "duty_cycle_tolerance_goal", self.duty_cycle_tolerance_goal
        )
        check_optional_type(
            self, "interference_tolerance_threshold", allowed_types=GainQuantity
        )
        check_optional_type(
            self, "interference_tolerance_goal", allowed_types=GainQuantity
        )
        if self.packet_loss_rate_tolerance_threshold:
            check_inclusive_bounds(
                "packet_loss_rate_tolerance_threshold",
                self.packet_loss_rate_tolerance_threshold,
            )
        if self.packet_loss_rate_tolerance_goal:
            check_inclusive_bounds(
                "packet_loss_rate_tolerance_goal", self.packet_loss_rate_tolerance_goal
            )
        if self.network_priority:
            check_inclusive_bounds(
                "network_priority",
                self.network_priority,
                maximum=10,
                allowed_types=(int),
            )
        check_optional_type(self, "incumbent_id", (int, float))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "networkId": str(self.network_id),
            "primaryFrequencyBand": self.primary_frequency_band.to_dict(),
            "dutyCycleToleranceThreshold": self.duty_cycle_tolerance_threshold,
            "dutyCycleToleranceGoal": self.duty_cycle_tolerance_goal,
        }
        if self.interference_tolerance_threshold:
            data[
                "interferenceToleranceThreshold"
            ] = self.interference_tolerance_threshold.to_dict()
        if self.interference_tolerance_goal:
            data[
                "interferenceToleranceGoal"
            ] = self.interference_tolerance_goal.to_dict()
        if self.packet_loss_rate_tolerance_threshold:
            data[
                "packetLossRateToleranceThreshold"
            ] = self.packet_loss_rate_tolerance_threshold
        if self.packet_loss_rate_tolerance_goal:
            data["packetLossRateToleranceGoal"] = self.packet_loss_rate_tolerance_goal
        if self.network_priority:
            data["networkPriority"] = self.network_priority
        if self.incumbent_id:
            data["incumbentId"] = self.incumbent_id
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetworkGuidance":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        network_id = UUID(data["networkId"])
        primary_frequency_band = FrequencyBand.from_dict(data["primaryFrequencyBand"])
        duty_cycle_tolerance_threshold = data["dutyCycleToleranceThreshold"]
        duty_cycle_tolerance_goal = data["dutyCycleToleranceGoal"]
        interference_tolerance_threshold = parse_optional(
            data, "interferenceToleranceThreshold", from_dict_class=GainQuantity
        )
        interference_tolerance_goal = parse_optional(
            data, "interferenceToleranceGoal", from_dict_class=GainQuantity
        )
        packet_loss_rate_tolerance_threshold = parse_optional(
            data, "packetLossRateToleranceThreshold"
        )
        packet_loss_rate_tolerance_goal = parse_optional(
            data, "packetLossRateToleranceGoal"
        )
        network_priority = parse_optional(data, "networkPriority")
        incumbent_id = parse_optional(data, "incumbentId")
        return NetworkGuidance(
            network_id=network_id,
            primary_frequency_band=primary_frequency_band,
            duty_cycle_tolerance_threshold=duty_cycle_tolerance_threshold,
            duty_cycle_tolerance_goal=duty_cycle_tolerance_goal,
            interference_tolerance_threshold=interference_tolerance_threshold,
            interference_tolerance_goal=interference_tolerance_goal,
            packet_loss_rate_tolerance_threshold=packet_loss_rate_tolerance_threshold,
            packet_loss_rate_tolerance_goal=packet_loss_rate_tolerance_goal,
            network_priority=network_priority,
            incumbent_id=incumbent_id,
        )


class EvaluationPeriodType(enum.IntEnum):
    """
    Defines valid types for the evaluationPeriod in
    PolicyGuidance.schema.json
    """

    # pylint: disable=invalid-name
    DayTimePeriod = enum.auto()
    TimeQuantity = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class EvaluationPeriod(TimeDurationInterface):
    """
    Defines a dataclass representing EvaluationPeriod.schema.json
    """

    __EVALUATION_PERIOD_TYPE_CLASS_MAP: ClassVar[dict] = {
        EvaluationPeriodType.DayTimePeriod: DayTimePeriod,
        EvaluationPeriodType.TimeQuantity: TimeQuantity,
    }

    duration: Union[DayTimePeriod, TimeQuantity]

    def __post_init__(self):
        check_object_field(
            self, "duration", allowed_types=(DayTimePeriod, TimeQuantity)
        )

    @property
    def duration_type(self) -> Union[str, None]:
        """
        Return the type of duration, or None
        """
        if self.duration:
            if isinstance(self.duration, DayTimePeriod):
                return EvaluationPeriodType.DayTimePeriod
            elif isinstance(self.duration, TimeQuantity):
                return EvaluationPeriodType.TimeQuantity
        return None

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            **self.duration.to_dict(),
            "type": str(self.duration_type),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "EvaluationPeriod":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        evaluation_period_type = EvaluationPeriodType[data["type"]]
        evaluation_class = cls.__EVALUATION_PERIOD_TYPE_CLASS_MAP[
            evaluation_period_type
        ]
        duration = evaluation_class.from_dict(data)
        return EvaluationPeriod(duration=duration)

    @property
    def sec(self) -> float:
        """
        Return the duration represented as seconds.
        """
        return self.duration.sec

    @property
    def msec(self) -> float:
        """
        Return the duration represented as milliseconds.
        """
        return self.duration.msec

    @property
    def usec(self) -> float:
        """
        Return the duration represented as microseconds.
        """
        return self.duration.usec


@dataclass(frozen=True)
class PolicyGuidance:
    """
    Defines a dataclass representing PolicyGuidance.schema.json.
    """

    policy_solution_id: Union[UUID, None] = None
    network_protection_list: Union[List[NetworkGuidance], None] = None
    maximum_allowable_processing_time: Union[TimeQuantity, None] = None
    evaluation_period: Union[EvaluationPeriod, None] = None

    def __post_init__(self):
        check_optional_type(self, "policy_solution_id", allowed_types=UUID)
        if self.network_protection_list is not None:
            check_object_list(
                self,
                "network_protection_list",
                allowed_types=NetworkGuidance,
                allow_empty=True,
            )
        check_optional_type(self, "policy_solution_id", allowed_types=UUID)
        if self.network_protection_list is not None:
            check_object_list(
                self,
                "network_protection_list",
                allowed_types=NetworkGuidance,
                allow_empty=True,
            )
        check_optional_type(
            self, "maximum_allowable_processing_time", allowed_types=TimeQuantity
        )
        check_optional_type(self, "evaluation_period", allowed_types=(EvaluationPeriod))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}
        if self.policy_solution_id:
            data["policySolutionId"] = str(self.policy_solution_id)
        if self.network_protection_list and len(self.network_protection_list) > 0:
            data["networkProtectionList"] = [
                item.to_dict() for item in self.network_protection_list
            ]
        if self.maximum_allowable_processing_time:
            data[
                "maximumAllowableProcessingTime"
            ] = self.maximum_allowable_processing_time.to_dict()
        if self.evaluation_period:
            data["evaluationPeriod"] = self.evaluation_period.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyGuidance":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        policy_solution_id = parse_optional(data, "policySolutionId")
        if policy_solution_id:
            policy_solution_id = UUID(policy_solution_id)
        network_protection_list = parse_optional_list(
            data, "networkProtectionList", from_dict_class=NetworkGuidance
        )
        maximum_allowable_processing_time = parse_optional(
            data, "maximumAllowableProcessingTime", from_dict_class=TimeQuantity
        )
        evaluation_period_data = data.get("evaluationPeriod", None)
        evaluation_period = None
        if evaluation_period_data:
            evaluation_period = parse_optional(
                data, "evaluationPeriod", from_dict_class=EvaluationPeriod
            )
        return PolicyGuidance(
            policy_solution_id=policy_solution_id,
            network_protection_list=network_protection_list,
            maximum_allowable_processing_time=maximum_allowable_processing_time,
            evaluation_period=evaluation_period,
        )


@dataclass(frozen=True)
class Ruleset:
    """
    Defines a dataclass representing Ruleset.schema.json.
    """

    ruleset_id: UUID
    frequency_rule_list: List[FrequencyBand]
    day_time_period_rule_list: Union[List[DayTimePeriod], None] = None
    geo_spatial_rule: Union[GeoSpatialInfo, None] = None
    transmission_type_rule: Union[TransmissionTypeRule, None] = None

    def __post_init__(self):
        check_object_field(self, "ruleset_id", UUID)
        check_object_list(self, "frequency_rule_list", FrequencyBand)
        if self.day_time_period_rule_list is not None:
            check_object_list(self, "day_time_period_rule_list", DayTimePeriod)
        check_optional_type(self, "geo_spatial_rule", GeoSpatialInfo)
        check_optional_type(self, "transmission_type_rule", TransmissionTypeRule)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "rulesetId": str(self.ruleset_id),
            "frequencyRuleList": [rule.to_dict() for rule in self.frequency_rule_list],
        }
        if self.day_time_period_rule_list:
            data["dayTimePeriodRuleList"] = [
                rule.to_dict() for rule in self.day_time_period_rule_list
            ]
        if self.geo_spatial_rule:
            data["geoSpatialRule"] = self.geo_spatial_rule.to_dict()
        if self.transmission_type_rule:
            data["transmissionTypeRule"] = self.transmission_type_rule.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Ruleset":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        ruleset_id = UUID(data["rulesetId"])
        frequency_rule_list = [
            FrequencyBand.from_dict(rule) for rule in data["frequencyRuleList"]
        ]
        day_time_period_rule_list = parse_optional_list(
            data, "dayTimePeriodRuleList", from_dict_class=DayTimePeriod
        )
        geo_spatial_rule = parse_optional(
            data, "geoSpatialRule", from_dict_class=GeoSpatialInfo
        )
        transmission_type_rule = parse_optional(
            data, "transmissionTypeRule", from_dict_class=TransmissionTypeRule
        )
        return Ruleset(
            ruleset_id=ruleset_id,
            frequency_rule_list=frequency_rule_list,
            day_time_period_rule_list=day_time_period_rule_list,
            geo_spatial_rule=geo_spatial_rule,
            transmission_type_rule=transmission_type_rule,
        )


class NetworkPolicyType(enum.IntEnum):
    """
    Defines valid enumerations for NetworkPolicy.schema.json
    """

    UNKNOWN = enum.auto()
    PERMISSIVE = enum.auto()
    PROHIBITIVE = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class NetworkPolicy:
    """
    Defines a dataclass representing NetworkPolicy.schema.json.
    """

    network_policy_id: UUID
    network_policy_type: NetworkPolicyType
    priority: int
    network_ruleset_list: List[Ruleset]

    def __post_init__(self):
        check_object_field(self, "network_policy_id", UUID)
        check_object_field(self, "network_policy_type", NetworkPolicyType)
        check_object_field(self, "priority", int)
        check_object_list(self, "network_ruleset_list", Ruleset)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "networkPolicyId": str(self.network_policy_id),
            "type": str(self.network_policy_type),
            "priority": self.priority,
            "networkRulesetList": [
                ruleset.to_dict() for ruleset in self.network_ruleset_list
            ],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetworkPolicy":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        network_policy_id = UUID(data["networkPolicyId"])
        network_policy_type = NetworkPolicyType[data["type"]]
        priority = data["priority"]
        network_ruleset_list = [
            Ruleset.from_dict(ruleset) for ruleset in data["networkRulesetList"]
        ]
        return NetworkPolicy(
            network_policy_id=network_policy_id,
            network_policy_type=network_policy_type,
            priority=priority,
            network_ruleset_list=network_ruleset_list,
        )


class DegreesNotationType(enum.IntEnum):
    """
    Defines notation types for latitude and longitude.
    """

    DEG = enum.auto()
    DEG_MM = enum.auto()
    DEG_MM_SEC = enum.auto()


@dataclass(frozen=True)
class Iso6709LocationString:
    """
    Defines a dataclass representing Iso6709LocationString.schema.json.
    """

    __LAT_PATTERN: ClassVar[
        str
    ] = "(?P<lat>(\\+|-)[0-9]{2}([0-9]{2})?([0-9]{2})?(\\.[0-9]+)?)"
    __LON_PATTERN: ClassVar[
        str
    ] = "(?P<lon>(\\+|-)[0-9]{3}([0-9]{2})?([0-9]{2})?(\\.[0-9]+)?)"
    __ALT_PATTERN: ClassVar[str] = "(?P<alt>(\\+|-)\\d+(\\.\\d+)?CRS(.*))"
    __COMBINED: ClassVar[str] = f"^{__LAT_PATTERN}{__LON_PATTERN}{__ALT_PATTERN}?/$"
    __PATTERN: ClassVar[re.Pattern] = re.compile(__COMBINED)

    latitude: Union[float, int]
    longitude: Union[float, int]
    latitude_type: DegreesNotationType = DegreesNotationType.DEG
    longitude_type: DegreesNotationType = DegreesNotationType.DEG
    altitude: Union[float, int, None] = None
    crs: Union[str, None] = None

    def __post_init__(self):
        check_object_field(self, "latitude", allowed_types=(float, int))
        check_object_field(self, "longitude", allowed_types=(float, int))
        check_object_field(self, "latitude_type", DegreesNotationType)
        check_object_field(self, "longitude_type", DegreesNotationType)
        check_optional_type(self, "altitude", allowed_types=(float, int))
        check_optional_type(self, "crs", str)

    def __str__(self) -> str:
        """
        Return Tranche2 compatible JSON.
        """
        if self.latitude_type == DegreesNotationType.DEG_MM:
            latitude_str = get_signed_dec_min_str_from_decimal(
                self.latitude, width_with_sign=3
            )
        elif self.latitude_type == DegreesNotationType.DEG_MM_SEC:
            latitude_str = get_signed_dec_min_sec_str_from_decimal(
                self.latitude, width_with_sign=3
            )
        else:
            latitude_str = get_signed_rounded_str(self.latitude, width_with_sign=3)

        if self.longitude_type == DegreesNotationType.DEG_MM:
            longitude_str = get_signed_dec_min_str_from_decimal(
                self.longitude, width_with_sign=4
            )
        elif self.longitude_type == DegreesNotationType.DEG_MM_SEC:
            longitude_str = get_signed_dec_min_sec_str_from_decimal(
                self.longitude, width_with_sign=4
            )
        else:
            longitude_str = get_signed_rounded_str(self.longitude, width_with_sign=4)

        altitude_str = ""
        crs_str = ""
        if self.altitude is not None:
            altitude_str = get_signed_rounded_str(self.altitude)
            crs_str = "CRS"
            if self.crs is not None:
                crs_str = self.crs
        return f"{latitude_str}{longitude_str}{altitude_str}{crs_str}/"

    @classmethod
    def from_string(cls, data: str) -> "Iso6709LocationString":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : str
            The string to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        match = re.match(cls.__PATTERN, data)
        if not match:
            raise ValueError("Invalid Iso6709LocationString")
        latitude_str = match.group("lat")
        latitude_pre_dot = latitude_str.split(".")[0]
        latitude_sign = 1
        if latitude_str[0] == "-":
            latitude_sign = -1
        if len(latitude_pre_dot) == 5:
            lat_deg = float(latitude_pre_dot[:3])
            lat_min = latitude_sign * float(latitude_str[3:])
            latitude = lat_deg + lat_min / 60
            latitude_type = DegreesNotationType.DEG_MM
        elif len(latitude_pre_dot) == 7:
            lat_deg = float(latitude_pre_dot[:3])
            lat_min = latitude_sign * float(latitude_pre_dot[3:5])
            lat_sec = latitude_sign * float(latitude_str[5:])
            latitude = lat_deg + lat_min / 60 + lat_sec / 3600
            latitude_type = DegreesNotationType.DEG_MM_SEC
        else:
            latitude = float(latitude_str)
            latitude_type = DegreesNotationType.DEG
        longitude_str = match.group("lon")
        longitude_pre_dot = longitude_str.split(".")[0]
        longitude_sign = 1
        if longitude_str[0] == "-":
            longitude_sign = -1
        if len(longitude_pre_dot) == 6:
            lon_deg = float(longitude_pre_dot[:4])
            lon_min = longitude_sign * float(longitude_str[4:])
            longitude = lon_deg + lon_min / 60
            longitude_type = DegreesNotationType.DEG_MM
        elif len(longitude_pre_dot) == 8:
            lon_deg = float(longitude_pre_dot[:4])
            lon_min = longitude_sign * float(longitude_pre_dot[4:6])
            lon_sec = longitude_sign * float(longitude_str[6:])
            longitude = lon_deg + lon_min / 60 + lon_sec / 3600
            longitude_type = DegreesNotationType.DEG_MM_SEC
        else:
            longitude = float(longitude_str)
            longitude_type = DegreesNotationType.DEG
        altitude_str = match.group("alt")
        altitude = None
        crs = None
        if altitude_str:
            idx = altitude_str.find("CRS")
            altitude = float(altitude_str[:idx])
            crs = altitude_str[idx:]
        return Iso6709LocationString(
            latitude=latitude,
            longitude=longitude,
            latitude_type=latitude_type,
            longitude_type=longitude_type,
            altitude=altitude,
            crs=crs,
        )


class GeoLocationPositionType(enum.IntEnum):
    """
    Defines allowable position types for GeoLocation.schema.json
    """

    # pylint: disable=invalid-name
    Iso6709LocationString = enum.auto()
    GeoSpatialInfo = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class GeoLocation:
    """
    Defines a dataclass representing GeoLocation.schema.json.
    """

    position: Union[Iso6709LocationString, GeoSpatialInfo]

    def __post_init__(self):
        check_object_field(
            self, "position", allowed_types=(Iso6709LocationString, GeoSpatialInfo)
        )

    @property
    def position_type(self) -> GeoLocationPositionType:
        """
        Get the type of the position
        """
        if isinstance(self.position, Iso6709LocationString):
            return GeoLocationPositionType.Iso6709LocationString
        return GeoLocationPositionType.GeoSpatialInfo

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        if self.position_type == GeoLocationPositionType.Iso6709LocationString:
            position_data = {"position": str(self.position)}
        else:
            position_data = self.position.to_dict()
        return {
            **position_data,
            "type": str(self.position_type),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoLocation":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        position_type = GeoLocationPositionType[data["type"]]
        if position_type == GeoLocationPositionType.Iso6709LocationString:
            position = Iso6709LocationString.from_string(data["position"])
        else:
            position = GeoSpatialInfo.from_dict(data)
        return GeoLocation(position=position)


@dataclass(frozen=True)
class SdsInfo:
    """
    Defines a dataclass representing SdsInfo.schema.json.
    """

    sds_id: UUID
    waveform_name: Union[str, None] = None
    location: Union[GeoLocation, None] = None

    def __post_init__(self):
        check_object_field(self, "sds_id", UUID)
        check_optional_type(self, "waveform_name", str)
        check_optional_type(self, "location", GeoLocation)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {"sdsId": str(self.sds_id)}
        if self.waveform_name:
            data["waveformName"] = self.waveform_name
        if self.location:
            data["location"] = self.location.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SdsInfo":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sds_id = UUID(data["sdsId"])
        waveform_name = parse_optional(data, "waveformName")
        location = parse_optional(data, "location", from_dict_class=GeoLocation)
        return SdsInfo(sds_id=sds_id, waveform_name=waveform_name, location=location)


@dataclass(frozen=True)
class NetworkInfo:
    """
    Defines a dataclass representing NetworkInfo.schema.json.
    """

    network_id: UUID
    policy_list: List[NetworkPolicy]
    sds_list: List[SdsInfo]

    def __post_init__(self):
        check_object_field(self, "network_id", UUID)
        check_object_list(self, "policy_list", allowed_types=NetworkPolicy)
        check_object_list(self, "sds_list", allowed_types=SdsInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "networkId": str(self.network_id),
            "policyList": [policy.to_dict() for policy in self.policy_list],
            "sdsList": [sds.to_dict() for sds in self.sds_list],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetworkInfo":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        network_id = UUID(data["networkId"])
        policy_list = [NetworkPolicy.from_dict(item) for item in data["policyList"]]
        sds_list = [SdsInfo.from_dict(item) for item in data["sdsList"]]
        return NetworkInfo(
            network_id=network_id, policy_list=policy_list, sds_list=sds_list
        )


@dataclass(frozen=True)
class PolicySolution:
    """
    Defines a dataclass representing PolicySolution.schema.json.
    """

    mission_id: UUID
    policy_solution_id: UUID
    network_info_list: List[NetworkInfo]

    def __post_init__(self):
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "policy_solution_id", UUID)
        check_object_list(self, "network_info_list", allowed_types=NetworkInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "missionId": str(self.mission_id),
            "policySolutionId": str(self.policy_solution_id),
            "networkInfoList": [info.to_dict() for info in self.network_info_list],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicySolution":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_id = UUID(data["missionId"])
        policy_solution_id = UUID(data["policySolutionId"])
        network_info_list = [
            NetworkInfo.from_dict(item) for item in data["networkInfoList"]
        ]
        return PolicySolution(
            mission_id=mission_id,
            policy_solution_id=policy_solution_id,
            network_info_list=network_info_list,
        )


@dataclass(frozen=True)
class PolicyAssessmentRequestMt:
    """
    Defines a dataclass representing PolicyAssessmentRequest_MT.schema.json.
    """

    policy_solution_list: List[PolicySolution]
    assessment_guidance_list: List[PolicyGuidance]

    def __post_init__(self):
        check_object_list(self, "policy_solution_list", allowed_types=PolicySolution)
        check_object_list(
            self, "assessment_guidance_list", allowed_types=PolicyGuidance
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "policySolutionList": [
                solution.to_dict() for solution in self.policy_solution_list
            ],
            "assessmentGuidanceList": [
                guidance.to_dict() for guidance in self.assessment_guidance_list
            ],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyAssessmentRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        policy_solution_list = [
            PolicySolution.from_dict(item) for item in data["policySolutionList"]
        ]
        assessment_guidance_list = [
            PolicyGuidance.from_dict(item) for item in data["assessmentGuidanceList"]
        ]
        return PolicyAssessmentRequestMt(
            policy_solution_list=policy_solution_list,
            assessment_guidance_list=assessment_guidance_list,
        )


@dataclass(frozen=True)
class NetworkAssessmentRisk:
    """
    Defines a dataclass representing NetworkAssessmentRisk.schema.json
    """

    network_id: UUID
    risk_score: Union[int, float]
    reason_code: int

    def __post_init__(self):
        check_object_field(self, "network_id", UUID)
        check_object_field(self, "risk_score", (int, float))
        check_inclusive_bounds("risk_score", self.risk_score)
        check_object_field(self, "reason_code", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "networkId": str(self.network_id),
            "riskScore": self.risk_score,
            "reasonCode": self.reason_code,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetworkAssessmentRisk":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        network_id = UUID(data["networkId"])
        risk_score = data["riskScore"]
        reason_code = data["reasonCode"]
        return NetworkAssessmentRisk(
            network_id=network_id, risk_score=risk_score, reason_code=reason_code
        )


@dataclass(frozen=True)
class PolicyAssessmentSummary:
    """
    Defines a dataclass representing PolicyAssessmentSummary.schema.json
    """

    policy_solution_id: UUID
    policy_risk_score: Union[int, float]
    high_risk_network_list: Union[List[NetworkAssessmentRisk], None] = None
    medium_risk_network_list: Union[List[NetworkAssessmentRisk], None] = None
    low_risk_network_list: Union[List[NetworkAssessmentRisk], None] = None

    def __post_init__(self):
        check_object_field(self, "policy_solution_id", UUID)
        check_object_field(self, "policy_risk_score", (int, float))
        check_inclusive_bounds("policy_risk_score", self.policy_risk_score)
        if self.high_risk_network_list:
            check_object_list(
                self,
                "high_risk_network_list",
                allowed_types=NetworkAssessmentRisk,
                allow_empty=True,
            )
        if self.medium_risk_network_list:
            check_object_list(
                self,
                "medium_risk_network_list",
                allowed_types=NetworkAssessmentRisk,
                allow_empty=True,
            )
        if self.low_risk_network_list:
            check_object_list(
                self,
                "low_risk_network_list",
                allowed_types=NetworkAssessmentRisk,
                allow_empty=True,
            )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "policySolutionId": str(self.policy_solution_id),
            "policyRiskScore": self.policy_risk_score,
        }
        if self.high_risk_network_list:
            data["highRiskNetworkList"] = [
                risk.to_dict() for risk in self.high_risk_network_list
            ]
        if self.medium_risk_network_list:
            data["mediumRiskNetworkList"] = [
                risk.to_dict() for risk in self.medium_risk_network_list
            ]
        if self.low_risk_network_list:
            data["lowRiskNetworkList"] = [
                risk.to_dict() for risk in self.low_risk_network_list
            ]
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyAssessmentSummary":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        policy_solution_id = UUID(data["policySolutionId"])
        policy_risk_score = data["policyRiskScore"]
        high_risk_network_list = parse_optional_list(
            data,
            "highRiskNetworkList",
            from_dict_class=NetworkAssessmentRisk,
            default=None,
        )
        medium_risk_network_list = parse_optional_list(
            data,
            "mediumRiskNetworkList",
            from_dict_class=NetworkAssessmentRisk,
            default=None,
        )
        low_risk_network_list = parse_optional_list(
            data,
            "lowRiskNetworkList",
            from_dict_class=NetworkAssessmentRisk,
            default=None,
        )
        return PolicyAssessmentSummary(
            policy_solution_id=policy_solution_id,
            policy_risk_score=policy_risk_score,
            high_risk_network_list=high_risk_network_list,
            medium_risk_network_list=medium_risk_network_list,
            low_risk_network_list=low_risk_network_list,
        )


@dataclass(frozen=True)
class RulesetRiskMetrics:
    """
    Defines a dataclass representing RulesetRiskMetrics.schema.json
    """

    risk_id: UUID
    network_policy_id: UUID
    ruleset_id: UUID
    # TODO: There should be a common risk score definition
    # there is a discrepancy here between a risk_score and in
    # NetworkAssessmentSummary risk score.
    risk_score: int
    risk_std_dev: int
    # TODO: the reason code should use an enumerated type
    reason_code: int
    confidence_score: int

    def __post_init__(self):
        check_object_field(self, "risk_id", UUID)
        check_object_field(self, "network_policy_id", UUID)
        check_object_field(self, "ruleset_id", UUID)
        check_object_field(self, "risk_score", int)
        check_inclusive_bounds("risk_score", self.risk_score)
        check_object_field(self, "risk_std_dev", int)
        check_object_field(self, "reason_code", int)
        check_object_field(self, "confidence_score", int)
        check_inclusive_bounds("confidence_score", self.confidence_score)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "riskId": str(self.risk_id),
            "networkPolicyId": str(self.network_policy_id),
            "rulesetId": str(self.ruleset_id),
            "riskScore": self.risk_score,
            "riskStdDev": self.risk_std_dev,
            "reasonCode": self.reason_code,
            "confidenceScore": self.confidence_score,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RulesetRiskMetrics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        risk_id = UUID(data["riskId"])
        network_policy_id = UUID(data["networkPolicyId"])
        ruleset_id = UUID(data["rulesetId"])
        risk_score = data["riskScore"]
        risk_std_dev = data["riskStdDev"]
        reason_code = data["reasonCode"]
        confidence_score = data["confidenceScore"]
        return RulesetRiskMetrics(
            risk_id=risk_id,
            network_policy_id=network_policy_id,
            ruleset_id=ruleset_id,
            risk_score=risk_score,
            risk_std_dev=risk_std_dev,
            reason_code=reason_code,
            confidence_score=confidence_score,
        )


@dataclass(frozen=True)
class SdsRulesetRiskMetrics(RulesetRiskMetrics):
    """
    Defines a dataclass representing SdsRulesetRiskMetrics.schema.json
    """

    geo_spatial_rule: Union[GeoSpatialInfo, None] = None
    transmission_type_rule: Union[TransmissionTypeRule, None] = None

    def __post_init__(self):
        super().__post_init__()
        check_optional_type(self, "geo_spatial_rule", GeoSpatialInfo)
        check_optional_type(self, "transmission_type_rule", TransmissionTypeRule)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = super().to_dict()
        if self.geo_spatial_rule:
            data["geoSpatialRule"] = self.geo_spatial_rule.to_dict()
        if self.transmission_type_rule:
            data["transmissionTypeRule"] = self.transmission_type_rule.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SdsRulesetRiskMetrics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        metrics = asdict(RulesetRiskMetrics.from_dict(data))
        geo_spatial_rule = parse_optional(
            data, "geoSpatialRule", from_dict_class=GeoSpatialInfo
        )
        transmission_type_rule = parse_optional(
            data, "transmissionTypeRule", from_dict_class=TransmissionTypeRule
        )
        return SdsRulesetRiskMetrics(
            **metrics,
            geo_spatial_rule=geo_spatial_rule,
            transmission_type_rule=transmission_type_rule,
        )


@dataclass(frozen=True)
class SdsRisk:
    """
    Defines a dataclass representing SdsRisk.schema.json
    """

    sds_id: UUID
    sds_ruleset_risk_metrics_list: List[SdsRulesetRiskMetrics]

    def __post_init__(self):
        check_object_field(self, "sds_id", UUID)
        check_object_list(self, "sds_ruleset_risk_metrics_list", SdsRulesetRiskMetrics)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "sdsId": str(self.sds_id),
            "sdsRulesetRiskMetricsList": [
                item.to_dict() for item in self.sds_ruleset_risk_metrics_list
            ],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SdsRisk":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sds_id = UUID(data["sdsId"])
        sds_ruleset_risk_metrics_list = [
            SdsRulesetRiskMetrics.from_dict(item)
            for item in data["sdsRulesetRiskMetricsList"]
        ]
        return SdsRisk(
            sds_id=sds_id,
            sds_ruleset_risk_metrics_list=sds_ruleset_risk_metrics_list,
        )


@dataclass(frozen=True)
class NetworkRisk:
    """
    Defines a dataclass representing NetworkRisk.schema.json
    """

    network_id: UUID
    network_ruleset_risk_metrics_list: List[RulesetRiskMetrics]
    sds_risk_list: List[SdsRisk]

    def __post_init__(self):
        check_object_field(self, "network_id", UUID)
        check_object_list(self, "network_ruleset_risk_metrics_list", RulesetRiskMetrics)
        check_object_list(self, "sds_risk_list", SdsRisk)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "networkId": str(self.network_id),
            "networkRulesetRiskMetricsList": [
                item.to_dict() for item in self.network_ruleset_risk_metrics_list
            ],
            "sdsRiskList": [item.to_dict() for item in self.sds_risk_list],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetworkRisk":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        network_id = UUID(data["networkId"])
        network_ruleset_risk_metrics_list = [
            RulesetRiskMetrics.from_dict(item)
            for item in data["networkRulesetRiskMetricsList"]
        ]
        sds_risk_list = [SdsRisk.from_dict(item) for item in data["sdsRiskList"]]
        return NetworkRisk(
            network_id=network_id,
            network_ruleset_risk_metrics_list=network_ruleset_risk_metrics_list,
            sds_risk_list=sds_risk_list,
        )


@dataclass(frozen=True)
class PolicyRisk:
    """
    Defines a dataclass representing PolicyRisk.schema.json
    """

    policy_solution_id: UUID
    network_risk_list: List[NetworkRisk]

    def __post_init__(self):
        check_object_field(self, "policy_solution_id", UUID)
        check_object_list(self, "network_risk_list", NetworkRisk)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "policySolutionId": str(self.policy_solution_id),
            "networkRiskList": [item.to_dict() for item in self.network_risk_list],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyRisk":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        policy_solution_id = UUID(data["policySolutionId"])
        network_risk_list = [
            NetworkRisk.from_dict(item) for item in data["networkRiskList"]
        ]
        return PolicyRisk(
            policy_solution_id=policy_solution_id,
            network_risk_list=network_risk_list,
        )


@dataclass(frozen=True)
class PolicyAssessmentResponseMt:
    """
    Defines a dataclass representing PolicyAssessmentResponse_MT.schema.json
    """

    request_message_id: UUID
    policy_assessment_summary_list: List[PolicyAssessmentSummary]
    policy_risk_list: List[PolicyRisk]

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_list(
            self, "policy_assessment_summary_list", PolicyAssessmentSummary
        )
        check_object_list(self, "policy_risk_list", PolicyRisk)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "policyAssessmentSummaryList": [
                item.to_dict() for item in self.policy_assessment_summary_list
            ],
            "policyRiskList": [item.to_dict() for item in self.policy_risk_list],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyAssessmentResponseMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        policy_assessment_summary_list = [
            PolicyAssessmentSummary.from_dict(item)
            for item in data["policyAssessmentSummaryList"]
        ]
        policy_risk_list = [
            PolicyRisk.from_dict(item) for item in data["policyRiskList"]
        ]
        return PolicyAssessmentResponseMt(
            request_message_id=request_message_id,
            policy_assessment_summary_list=policy_assessment_summary_list,
            policy_risk_list=policy_risk_list,
        )


@dataclass(frozen=True)
class PolicyGenerationRequestMt:
    """
    Defines a dataclass representing PolicyGenerationRequest_MT.schema.json.
    """

    mission_id: UUID
    request_guidance: PolicyGuidance

    def __post_init__(self):
        check_object_field(self, "mission_id", allowed_types=UUID)
        check_object_field(self, "request_guidance", allowed_types=PolicyGuidance)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "missionId": str(self.mission_id),
            "requestGuidance": self.request_guidance.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyGenerationRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_id = UUID(data["missionId"])
        request_guidance = PolicyGuidance.from_dict(data["requestGuidance"])
        return PolicyGenerationRequestMt(
            mission_id=mission_id, request_guidance=request_guidance
        )


# TODO:
# This schema is undefined in tranche2 schemas and needs to be revisited when defined
@dataclass(frozen=True)
class PolicyOptimizationGuidance:
    """
    Defines the dataclass for PolicyOptimizationGuidance.schema.json
    """

    data: Dict[str, Any]

    def __post_init__(self):
        check_object_field(self, "data", dict)

    def to_dict(self):
        """
        Return Tranche2 compatible JSON.
        """
        return self.data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyOptimizationGuidance":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        return PolicyOptimizationGuidance(data=data)


@dataclass(frozen=True)
class PolicyOptimizationRequestMt:
    """
    Defines a dataclass representing PolicyOptimizationRequest_MT.schema.json.
    """

    policy_solution_list: List[PolicySolution]
    optimization_guidance_list: List[PolicyOptimizationGuidance]

    def __post_init__(self):
        check_object_list(self, "policy_solution_list", PolicySolution)
        check_object_list(
            self, "optimization_guidance_list", PolicyOptimizationGuidance
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "policySolutionList": [
                item.to_dict() for item in self.policy_solution_list
            ],
            "optimizationGuidanceList": [
                item.to_dict() for item in self.optimization_guidance_list
            ],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyOptimizationRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        policy_solution_list = [
            PolicySolution.from_dict(item) for item in data["policySolutionList"]
        ]
        optimization_guidance_list = [
            PolicyOptimizationGuidance.from_dict(item)
            for item in data["optimizationGuidanceList"]
        ]
        return PolicyOptimizationRequestMt(
            policy_solution_list=policy_solution_list,
            optimization_guidance_list=optimization_guidance_list,
        )


@dataclass(frozen=True)
class RiskInformedPolicyResponseMt:
    """
    Defines a dataclass representing RiskInformedPolicyResponse_MT.schema.json
    """

    request_message_id: UUID
    policy_solution_list: List[PolicySolution]
    policy_risk_list: List[PolicyRisk]
    policy_assessment_summary_list: Union[List[PolicyAssessmentSummary], None] = None

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_list(
            self, "policy_solution_list", PolicySolution, allow_empty=True
        )
        check_object_list(self, "policy_risk_list", PolicyRisk, allow_empty=True)
        if self.policy_assessment_summary_list:
            check_object_list(
                self,
                "policy_assessment_summary_list",
                PolicyAssessmentSummary,
                allow_empty=True,
            )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "requestMessageId": str(self.request_message_id),
            "policySolutionList": [
                item.to_dict() for item in self.policy_solution_list
            ],
            "policyRiskList": [item.to_dict() for item in self.policy_risk_list],
        }
        if self.policy_assessment_summary_list is not None:
            data["policyAssessmentSummaryList"] = [
                item.to_dict() for item in self.policy_assessment_summary_list
            ]
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RiskInformedPolicyResponseMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        policy_solution_list = [
            PolicySolution.from_dict(item) for item in data["policySolutionList"]
        ]
        policy_risk_list = [
            PolicyRisk.from_dict(item) for item in data["policyRiskList"]
        ]
        policy_assessment_summary_list = parse_optional_list(
            data, "policyAssessmentSummaryList", from_dict_class=PolicyAssessmentSummary
        )
        return RiskInformedPolicyResponseMt(
            request_message_id=request_message_id,
            policy_solution_list=policy_solution_list,
            policy_risk_list=policy_risk_list,
            policy_assessment_summary_list=policy_assessment_summary_list,
        )


@dataclass(frozen=True)
class AntennaInfo:
    """
    Defines a dataclass representing AntennaInfo.schema.json
    """

    type: str
    design: str
    product_name: str
    gain_data: List[GainFreqQuantity]
    supported_bands: List[FrequencyBand]
    max_power: PowerQuantity
    channel_designation: int
    beam_pattern: BeamPattern
    orientation: Union[AngleQuantity, None] = None

    def __post_init__(self):
        check_object_field(self, "type", str)
        check_object_field(self, "design", str)
        check_object_field(self, "product_name", str)
        check_object_list(self, "gain_data", GainFreqQuantity, allow_empty=True)
        check_object_list(self, "supported_bands", FrequencyBand, allow_empty=True)
        check_object_field(self, "max_power", PowerQuantity)
        check_object_field(self, "channel_designation", int)
        check_object_field(self, "beam_pattern", BeamPattern)
        check_optional_type(self, "orientation", AngleQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "type": self.type,
            "design": self.design,
            "productName": self.product_name,
            "gainData": [item.to_dict() for item in self.gain_data],
            "supportedBands": [item.to_dict() for item in self.supported_bands],
            "maxPower": self.max_power.to_dict(),
            "channelDesignation": self.channel_designation,
            "beamPattern": self.beam_pattern.to_dict(),
        }
        if self.orientation is not None:
            data["orientation"] = self.orientation.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AntennaInfo":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        antenna_type = data["type"]
        design = data["design"]
        product_name = data["productName"]
        gain_data = [GainFreqQuantity.from_dict(item) for item in data["gainData"]]
        supported_bands = [
            FrequencyBand.from_dict(item) for item in data["supportedBands"]
        ]
        max_power = PowerQuantity.from_dict(data["maxPower"])
        channel_designation = data["channelDesignation"]
        beam_pattern = BeamPattern.from_dict(data["beamPattern"])
        orientation = parse_optional(data, "orientation", from_dict_class=AngleQuantity)
        return AntennaInfo(
            type=antenna_type,
            design=design,
            product_name=product_name,
            gain_data=gain_data,
            supported_bands=supported_bands,
            max_power=max_power,
            channel_designation=channel_designation,
            beam_pattern=beam_pattern,
            orientation=orientation,
        )


@dataclass(frozen=True)
class SdrInfo:
    """
    Defines a dataclass representing SDRInfo.schema.json
    """

    type: str
    tuning_frequency: FrequencyBand
    max_instantaneous_bandwidth: FrequencyQuantity
    num_channels: int
    channel_designation_list: List[int]
    channel_coherence: bool

    def __post_init__(self):
        check_object_field(self, "type", str)
        check_object_field(self, "tuning_frequency", FrequencyBand)
        check_object_field(self, "max_instantaneous_bandwidth", FrequencyQuantity)
        check_object_field(self, "num_channels", int)
        check_object_list(self, "channel_designation_list", int, allow_empty=True)
        check_object_field(self, "channel_coherence", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "type": self.type,
            "tuningFreq": self.tuning_frequency.to_dict(),
            "maxInstBandwidth": self.max_instantaneous_bandwidth.to_dict(),
            "numChannels": self.num_channels,
            "channelDesignation": self.channel_designation_list,
            "channelCoherence": self.channel_coherence,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SdrInfo":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sdr_type = data["type"]
        tuning_frequency = FrequencyBand.from_dict(data["tuningFreq"])
        max_instantaneous_bandwidth = FrequencyQuantity.from_dict(
            data["maxInstBandwidth"]
        )
        num_channels = data["numChannels"]
        channel_designation_list = data["channelDesignation"]
        channel_coherence = data["channelCoherence"]
        return SdrInfo(
            type=sdr_type,
            tuning_frequency=tuning_frequency,
            max_instantaneous_bandwidth=max_instantaneous_bandwidth,
            num_channels=num_channels,
            channel_designation_list=channel_designation_list,
            channel_coherence=channel_coherence,
        )


class SensorInfoTxRxConfig(enum.IntEnum):
    """
    Defines an enumeration for txRxConfig in SensorInfo.schema.json
    """

    # pylint: disable=invalid-name
    Tx = enum.auto()
    Rx = enum.auto()
    Both = enum.auto()

    def __str__(self):
        return self.name


class SensorInfoStatus(enum.IntEnum):
    """
    Defines an enumeration for status in SensorInfo.schema.json
    """

    # pylint: disable=invalid-name
    Active = enum.auto()
    Inactive = enum.auto()
    Maintenance = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class SensorInfo:
    """
    Defines a dataclass representing SensorInfo.schema.json
    """

    sensor_id: UUID
    name: str
    sensor_type: str
    num_channels: int
    sdr_info_list: List[SdrInfo]
    antenna_conf_list: List[AntennaInfo]
    location: GeoLocation
    # TODO: add support for validating ipv4 format, perhaps using pydantic?
    ip_address: Union[str, None] = None
    tx_rx_config: Union[SensorInfoTxRxConfig, None] = None
    status: Union[SensorInfoStatus, None] = None
    calibrated: Union[bool, None] = None

    def __post_init__(self):
        check_object_field(self, "sensor_id", UUID)
        check_object_field(self, "name", str)
        check_object_field(self, "sensor_type", str)
        check_object_field(self, "num_channels", int)
        check_object_list(self, "sdr_info_list", SdrInfo, allow_empty=True)
        check_object_list(self, "antenna_conf_list", AntennaInfo, allow_empty=True)
        check_object_field(self, "location", GeoLocation)
        check_optional_type(self, "ip_address", str)
        check_optional_type(self, "tx_rx_config", SensorInfoTxRxConfig)
        check_optional_type(self, "status", SensorInfoStatus)
        check_optional_type(self, "calibrated", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "id": str(self.sensor_id),
            "name": self.name,
            "type": self.sensor_type,
            "numChannels": self.num_channels,
            "sdrInfo": [item.to_dict() for item in self.sdr_info_list],
            "antennaConf": [item.to_dict() for item in self.antenna_conf_list],
            "location": self.location.to_dict(),
        }
        if self.ip_address is not None:
            data["ipAddress"] = self.ip_address
        if self.tx_rx_config is not None:
            data["txRxConfig"] = str(self.tx_rx_config)
        if self.status is not None:
            data["status"] = str(self.status)
        if self.calibrated is not None:
            data["calibrated"] = self.calibrated
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SensorInfo":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sensor_id = UUID(data["id"])
        name = data["name"]
        sensor_type = data["type"]
        num_channels = data["numChannels"]
        sdr_info_list = [SdrInfo.from_dict(item) for item in data["sdrInfo"]]
        antenna_conf_list = [
            AntennaInfo.from_dict(item) for item in data["antennaConf"]
        ]
        location = GeoLocation.from_dict(data["location"])
        ip_address = parse_optional(data, "ipAddress")
        tx_rx_config = parse_optional(data, "txRxConfig")
        if tx_rx_config is not None:
            tx_rx_config = SensorInfoTxRxConfig[tx_rx_config]
        status = parse_optional(data, "status")
        if status is not None:
            status = SensorInfoStatus[status]
        calibrated = parse_optional(data, "calibrated")
        return SensorInfo(
            sensor_id=sensor_id,
            name=name,
            sensor_type=sensor_type,
            num_channels=num_channels,
            sdr_info_list=sdr_info_list,
            antenna_conf_list=antenna_conf_list,
            location=location,
            ip_address=ip_address,
            tx_rx_config=tx_rx_config,
            status=status,
            calibrated=calibrated,
        )


@dataclass(frozen=True)
class SensorConfigurationMt:
    """
    Defines a dataclass representing SensorConfiguration_MT.schema.json
    """

    request_message_id: Union[UUID, None] = None
    sensor: Union[SensorInfo, None] = None

    def __post_init__(self):
        check_optional_type(self, "request_message_id", UUID)
        check_optional_type(self, "sensor", SensorInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}
        if self.request_message_id is not None:
            data["requestMessageId"] = str(self.request_message_id)
        if self.sensor is not None:
            data["sensor"] = self.sensor.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SensorConfigurationMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = parse_optional(data, "requestMessageId")
        if request_message_id is not None:
            request_message_id = UUID(request_message_id)
        sensor = parse_optional(data, "sensor", from_dict_class=SensorInfo)
        return SensorConfigurationMt(
            request_message_id=request_message_id, sensor=sensor
        )


@dataclass(frozen=True)
class SensorNetworkDescriptorMt:
    """
    Defines a dataclass representing SensorNetworkDescriptor_MT.schema.json
    """

    sensors: List[UUID]
    request_message_id: Union[UUID, None] = None
    region: Union[GeoSpatialInfo, None] = None

    def __post_init__(self):
        check_object_list(self, "sensors", UUID, allow_empty=True)
        check_optional_type(self, "request_message_id", UUID)
        check_optional_type(self, "region", GeoSpatialInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {"sensors": [str(sensor_id) for sensor_id in self.sensors]}
        if self.request_message_id is not None:
            data["requestMessageId"] = str(self.request_message_id)
        if self.region is not None:
            data["region"] = self.region.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SensorNetworkDescriptorMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sensors = [UUID(item) for item in data["sensors"]]
        request_message_id = parse_optional(data, "requestMessageId")
        if request_message_id is not None:
            request_message_id = UUID(request_message_id)
        region = parse_optional(data, "region", from_dict_class=GeoSpatialInfo)
        return SensorNetworkDescriptorMt(
            sensors=sensors, request_message_id=request_message_id, region=region
        )


@dataclass(frozen=True)
class SensorNetworkDescriptorRequestMt:
    """
    Defines a dataclass representing SensorNetworkDescriptorRequest_MT.schema.json
    """

    # TODO: update schema to use sensors (plural) to match SensorNetworkDescriptor
    sensor: Union[List[UUID], None] = None
    # TODO: define region the same as SensorNetworkDescriptor?
    region: Union[GeoLocation, None] = None

    def __post_init__(self):
        if self.sensor is not None:
            check_object_list(self, "sensor", UUID, allow_empty=True)
        check_optional_type(self, "region", GeoLocation)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}
        if self.sensor is not None:
            data["sensor"] = [str(sensor_id) for sensor_id in self.sensor]
        if self.region is not None:
            data["region"] = self.region.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SensorNetworkDescriptorRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sensor = parse_optional_list(data, "sensor")
        if sensor is not None:
            sensor = [UUID(item) for item in sensor]
        region = parse_optional(data, "region", from_dict_class=GeoLocation)
        return SensorNetworkDescriptorRequestMt(sensor=sensor, region=region)


@dataclass(frozen=True)
class SensorData:
    """
    Defines a dataclass representing SensorData.schema.json
    """

    sensor_id: UUID
    sensor_position: GeoLocation
    name: Union[str, None] = None
    db_offset: Union[int, float, None] = None
    sensor_frequency_band: Union[FrequencyBand, None] = None

    def __post_init__(self):
        check_object_field(self, "sensor_id", UUID)
        check_object_field(self, "sensor_position", GeoLocation)
        check_optional_type(self, "name", str)
        check_optional_type(self, "db_offset", (int, float))
        check_optional_type(self, "sensor_frequency_band", FrequencyBand)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "sensorId": str(self.sensor_id),
            "sensorPosition": self.sensor_position.to_dict(),
        }
        if self.name is not None:
            data["name"] = self.name
        if self.db_offset is not None:
            data["dbOffset"] = self.db_offset
        if self.sensor_frequency_band is not None:
            data["sensorFrequencyBand"] = self.sensor_frequency_band.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SensorData":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        sensor_id = UUID(data["sensorId"])
        sensor_position = GeoLocation.from_dict(data["sensorPosition"])
        name = parse_optional(data, "name")
        db_offset = parse_optional(data, "dbOffset")
        sensor_frequency_band = parse_optional(
            data, "sensorFrequencyBand", from_dict_class=FrequencyBand
        )
        return SensorData(
            sensor_id=sensor_id,
            sensor_position=sensor_position,
            name=name,
            db_offset=db_offset,
            sensor_frequency_band=sensor_frequency_band,
        )


@dataclass(frozen=True)
class SignalCharacteristics:
    """
    Defines a dataclass representing SignalCharacteristics.schema.json
    """

    prf: Union[FrequencyQuantity, None] = None
    duty_cycle: Union[FractionQuantity, None] = None
    modulation: Union[str, None] = None
    pulse_width: Union[TimeQuantity, None] = None

    def __post_init__(self):
        check_optional_type(self, "prf", FrequencyQuantity)
        check_optional_type(self, "duty_cycle", FractionQuantity)
        check_optional_type(self, "modulation", str)
        check_optional_type(self, "pulse_width", TimeQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}
        if self.prf is not None:
            data["prf"] = self.prf.to_dict()
        if self.duty_cycle is not None:
            data["dutyCycle"] = self.duty_cycle.to_dict()
        if self.modulation is not None:
            data["modulation"] = self.modulation
        if self.pulse_width is not None:
            data["pulseWidth"] = self.pulse_width.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SignalCharacteristics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        prf = parse_optional(data, "prf", FrequencyQuantity)
        duty_cycle = parse_optional(data, "dutyCycle", FractionQuantity)
        modulation = parse_optional(data, "modulation")
        pulse_width = parse_optional(data, "pulseWidth", TimeQuantity)
        return SignalCharacteristics(
            prf=prf,
            duty_cycle=duty_cycle,
            modulation=modulation,
            pulse_width=pulse_width,
        )


@dataclass(frozen=True)
class SignalData:
    """
    Defines a dataclass representing SignalData.schema.json
    """

    signal_id: UUID
    signal_characteristics: SignalCharacteristics
    observed_time: dt
    frequency_band: FrequencyBand
    snr: PowerQuantity
    signal_class: Union[str, None] = None
    confidence: Union[FractionQuantity, None] = None
    signal_power: Union[PowerQuantity, None] = None
    noise_power: Union[PowerQuantity, None] = None
    interference_power: Union[PowerQuantity, None] = None

    def __post_init__(self):
        check_object_field(self, "signal_id", UUID)
        check_object_field(self, "signal_characteristics", SignalCharacteristics)
        check_object_field(self, "observed_time", dt)
        check_object_field(self, "frequency_band", FrequencyBand)
        check_object_field(self, "snr", PowerQuantity)
        check_optional_type(self, "signal_class", str)
        check_optional_type(self, "confidence", FractionQuantity)
        check_optional_type(self, "signal_power", PowerQuantity)
        check_optional_type(self, "noise_power", PowerQuantity)
        check_optional_type(self, "interference_power", PowerQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "signalId": str(self.signal_id),
            "signalCharacteristics": self.signal_characteristics.to_dict(),
            "observedTime": get_timestamp_as_str(self.observed_time),
            "frequencyBand": self.frequency_band.to_dict(),
            "snr": self.snr.to_dict(),
        }
        if self.signal_class is not None:
            data["signalClass"] = self.signal_class
        if self.confidence is not None:
            data["confidence"] = self.confidence.to_dict()
        if self.signal_power is not None:
            data["signalPower"] = self.signal_power.to_dict()
        if self.noise_power is not None:
            data["noisePower"] = self.noise_power.to_dict()
        if self.interference_power is not None:
            data["interferencePower"] = self.interference_power.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SignalData":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        signal_id = UUID(data["signalId"])
        signal_characteristics = SignalCharacteristics.from_dict(
            data["signalCharacteristics"]
        )
        observed_time = get_timestamp_from_str(data["observedTime"])
        frequency_band = FrequencyBand.from_dict(data["frequencyBand"])
        snr = PowerQuantity.from_dict(data["snr"])
        signal_class = parse_optional(data, "signalClass")
        confidence = parse_optional(data, "confidence", FractionQuantity)
        signal_power = parse_optional(data, "signalPower", PowerQuantity)
        noise_power = parse_optional(data, "noisePower", PowerQuantity)
        interference_power = parse_optional(data, "interferencePower", PowerQuantity)
        return SignalData(
            signal_id=signal_id,
            signal_characteristics=signal_characteristics,
            observed_time=observed_time,
            frequency_band=frequency_band,
            snr=snr,
            signal_class=signal_class,
            confidence=confidence,
            signal_power=signal_power,
            noise_power=noise_power,
            interference_power=interference_power,
        )


class SpectrumDataRecordType(enum.IntEnum):
    """
    Defines enumerations for the SpectrumDataRecord.schema.json record types.
    """

    # pylint: disable=invalid-name
    SignalList = enum.auto()
    FreqScanResp = enum.auto()
    IQSnippetResp = enum.auto()
    LOBResp = enum.auto()
    TDOAResp = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class ClassificationResponseRecord:
    """
    Defines a dataclass representing ClassificationResponseRecord.schema.json
    """

    entry_id: UUID
    sensor: SensorData
    signal_data: List[SignalData]

    @property
    def type(self) -> SpectrumDataRecordType:
        """
        Return SpectrumDataRecordType
        """
        return SpectrumDataRecordType.SignalList

    def __post_init__(self):
        check_object_field(self, "entry_id", UUID)
        check_object_field(self, "sensor", SensorData)
        check_object_list(self, "signal_data", SignalData, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "resultType": str(self.type),
            "entryId": str(self.entry_id),
            "sensor": self.sensor.to_dict(),
            "signalData": [item.to_dict() for item in self.signal_data],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ClassificationResponseRecord":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        entry_id = UUID(data["entryId"])
        sensor = SensorData.from_dict(data["sensor"])
        signal_data = [SignalData.from_dict(item) for item in data["signalData"]]
        return ClassificationResponseRecord(
            entry_id=entry_id,
            sensor=sensor,
            signal_data=signal_data,
        )


@dataclass(frozen=True)
class ScanValues:
    """
    Defines a dataclass representing ScanValues.schema.json
    """

    min: Union[int, float, None] = None
    max: Union[int, float, None] = None
    avg: Union[np.ndarray, None] = None

    def __post_init__(self):
        check_optional_type(self, "min", (int, float))
        check_optional_type(self, "max", (int, float))
        check_optional_type(self, "avg", np.ndarray)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}
        if self.min is not None:
            data["min"] = self.min
        if self.max is not None:
            data["max"] = self.max
        if self.avg is not None:
            data["avg"] = self.avg.tolist()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ScanValues":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        min_value = parse_optional(data, "min")
        max_value = parse_optional(data, "max")
        avg = parse_optional_list(data, "avg")
        if avg is not None:
            avg = np.asarray(avg)
        return ScanValues(min=min_value, max=max_value, avg=avg)


@dataclass(frozen=True)
class FreqScanResults:
    """
    Defines a dataclass representing FreqScanResults.schema.json
    """

    frequency_band: FrequencyBand
    time_duration: DayTimePeriod
    antenna_id: Union[int, None] = None
    vals: Union[ScanValues, None] = None

    def __post_init__(self):
        check_object_field(self, "frequency_band", FrequencyBand)
        check_object_field(self, "time_duration", DayTimePeriod)
        check_optional_type(self, "antenna_id", int)
        check_optional_type(self, "vals", ScanValues)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "frequencyBand": self.frequency_band.to_dict(),
            "timeDuration": self.time_duration.to_dict(),
        }
        if self.antenna_id is not None:
            data["antennaID"] = self.antenna_id
        if self.vals is not None:
            data["vals"] = self.vals.to_dict()
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FreqScanResults":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        frequency_band = FrequencyBand.from_dict(data["frequencyBand"])
        time_duration = DayTimePeriod.from_dict(data["timeDuration"])
        antenna_id = parse_optional(data, "antennaID")
        vals = parse_optional(data, "vals", from_dict_class=ScanValues)
        return FreqScanResults(
            frequency_band=frequency_band,
            time_duration=time_duration,
            antenna_id=antenna_id,
            vals=vals,
        )


@dataclass(frozen=True)
class FrequencyResponseRecord:
    """
    Defines a dataclass representing FrequencyResponseRecord.schema.json
    """

    entry_id: UUID
    request_task_id: UUID
    scan_results: FreqScanResults
    sensor: SensorData
    record_version: int

    @property
    def type(self) -> SpectrumDataRecordType:
        """
        Return SpectrumDataRecordType
        """
        return SpectrumDataRecordType.FreqScanResp

    def __post_init__(self):
        check_object_field(self, "entry_id", UUID)
        check_object_field(self, "request_task_id", UUID)
        check_object_field(self, "scan_results", FreqScanResults)
        check_object_field(self, "sensor", SensorData)
        check_object_field(self, "record_version", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "resultType": str(self.type),
            "entryId": str(self.entry_id),
            "requestTaskId": str(self.request_task_id),
            "scanResults": self.scan_results.to_dict(),
            "sensor": self.sensor.to_dict(),
            "recordVersion": self.record_version,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyResponseRecord":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        entry_id = UUID(data["entryId"])
        request_task_id = UUID(data["requestTaskId"])
        scan_results = FreqScanResults.from_dict(data["scanResults"])
        sensor = SensorData.from_dict(data["sensor"])
        record_version = data["recordVersion"]
        return FrequencyResponseRecord(
            entry_id=entry_id,
            request_task_id=request_task_id,
            scan_results=scan_results,
            sensor=sensor,
            record_version=record_version,
        )


@dataclass(frozen=True)
class IqResponseRecord:
    """
    Defines a dataclass representing IqResponseRecord.schema.json
    """

    entry_id: UUID
    request_task_id: UUID
    gain_setting: Union[int, float]
    min_frequency: FrequencyQuantity
    max_frequency: FrequencyQuantity
    tdoa_flag: bool
    end_time: dt
    location: GeoLocation
    sensor: SensorData
    iq_bin_data: np.ndarray
    record_version: int
    antenna_id: Union[int, None] = None

    @property
    def type(self) -> SpectrumDataRecordType:
        """
        Return SpectrumDataRecordType
        """
        return SpectrumDataRecordType.IQSnippetResp

    def __post_init__(self):
        check_object_field(self, "entry_id", UUID)
        check_object_field(self, "request_task_id", UUID)
        check_object_field(self, "gain_setting", (int, float))
        check_object_field(self, "min_frequency", FrequencyQuantity)
        check_object_field(self, "max_frequency", FrequencyQuantity)
        check_object_field(self, "tdoa_flag", bool)
        check_object_field(self, "end_time", dt)
        check_object_field(self, "location", GeoLocation)
        check_object_field(self, "sensor", SensorData)
        check_object_field(self, "iq_bin_data", np.ndarray)
        check_object_field(self, "record_version", int)
        check_optional_type(self, "antenna_id", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "resultType": str(self.type),
            "entryId": str(self.entry_id),
            "requestTaskId": str(self.request_task_id),
            "gainSetting": self.gain_setting,
            "minFrequency": self.min_frequency.to_dict(),
            "maxFrequency": self.max_frequency.to_dict(),
            "tdoaFlag": self.tdoa_flag,
            "endTime": get_timestamp_as_str(self.end_time),
            "location": self.location.to_dict(),
            "sensor": self.sensor.to_dict(),
            "iqBinData": self.iq_bin_data.tolist(),
            "recordVersion": self.record_version,
        }
        if self.antenna_id is not None:
            data["antennaId"] = self.antenna_id
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IqResponseRecord":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        entry_id = UUID(data["entryId"])
        request_task_id = UUID(data["requestTaskId"])
        gain_setting = data["gainSetting"]
        min_frequency = FrequencyQuantity.from_dict(data["minFrequency"])
        max_frequency = FrequencyQuantity.from_dict(data["maxFrequency"])
        tdoa_flag = data["tdoaFlag"]
        end_time = get_timestamp_from_str(data["endTime"])
        location = GeoLocation.from_dict(data["location"])
        sensor = SensorData.from_dict(data["sensor"])
        iq_bin_data = np.asarray(data["iqBinData"])
        record_version = data["recordVersion"]
        antenna_id = parse_optional(data, "antennaId")
        return IqResponseRecord(
            entry_id=entry_id,
            request_task_id=request_task_id,
            gain_setting=gain_setting,
            min_frequency=min_frequency,
            max_frequency=max_frequency,
            tdoa_flag=tdoa_flag,
            end_time=end_time,
            location=location,
            sensor=sensor,
            iq_bin_data=iq_bin_data,
            record_version=record_version,
            antenna_id=antenna_id,
        )


@dataclass(frozen=True)
class LobResponseRecord:
    """
    Defines a dataclass representing LobResponseRecord.schema.json
    """

    entry_id: UUID
    request_task_id: UUID
    location: GeoLocation
    sensor: SensorData
    time_difference1: dt
    time_difference2: dt
    record_version: int

    @property
    def type(self) -> SpectrumDataRecordType:
        """
        Return SpectrumDataRecordType
        """
        return SpectrumDataRecordType.LOBResp

    def __post_init__(self):
        check_object_field(self, "entry_id", UUID)
        check_object_field(self, "request_task_id", UUID)
        check_object_field(self, "location", GeoLocation)
        check_object_field(self, "sensor", SensorData)
        check_object_field(self, "time_difference1", dt)
        check_object_field(self, "time_difference2", dt)
        check_object_field(self, "record_version", int)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "resultType": str(self.type),
            "entryId": str(self.entry_id),
            "requestTaskId": str(self.request_task_id),
            "location": self.location.to_dict(),
            "sensor": self.sensor.to_dict(),
            "timeDifference1": get_timestamp_as_str(self.time_difference1),
            "timeDifference2": get_timestamp_as_str(self.time_difference2),
            "recordVersion": self.record_version,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LobResponseRecord":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        entry_id = UUID(data["entryId"])
        request_task_id = UUID(data["requestTaskId"])
        location = GeoLocation.from_dict(data["location"])
        sensor = SensorData.from_dict(data["sensor"])
        time_difference1 = get_timestamp_from_str(data["timeDifference1"])
        time_difference2 = get_timestamp_from_str(data["timeDifference2"])
        record_version = data["recordVersion"]
        return LobResponseRecord(
            entry_id=entry_id,
            request_task_id=request_task_id,
            location=location,
            sensor=sensor,
            time_difference1=time_difference1,
            time_difference2=time_difference2,
            record_version=record_version,
        )


@dataclass(frozen=True)
class TdoaResponseRecord:
    """
    Defines a dataclass representing TdoaResponseRecord.schema.json
    """

    entry_id: UUID
    request_task_id: UUID
    distances: np.ndarray
    sensors_key: List[str]
    sensors_ids: List[UUID]
    sensor_pairs: List[str]
    bounding_area: GeoLocation
    tdoa_heatmap_image: str

    @property
    def type(self) -> SpectrumDataRecordType:
        """
        Return SpectrumDataRecordType
        """
        return SpectrumDataRecordType.TDOAResp

    def __post_init__(self):
        check_object_field(self, "entry_id", UUID)
        check_object_field(self, "request_task_id", UUID)
        check_object_field(self, "distances", np.ndarray)
        check_object_list(self, "sensors_key", str, allow_empty=True)
        check_object_list(self, "sensors_ids", UUID, allow_empty=True)
        check_object_list(self, "sensor_pairs", str, allow_empty=True)
        check_object_field(self, "bounding_area", GeoLocation)
        check_object_field(self, "tdoa_heatmap_image", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "resultType": str(self.type),
            "entryId": str(self.entry_id),
            "requestTaskId": str(self.request_task_id),
            "distances": self.distances.tolist(),
            "sensorsKey": self.sensors_key,
            "sensorsIds": [str(item) for item in self.sensors_ids],
            "sensorPairs": self.sensor_pairs,
            "boundingArea": self.bounding_area.to_dict(),
            "tdoaHeatmapImage": self.tdoa_heatmap_image,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TdoaResponseRecord":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        entry_id = UUID(data["entryId"])
        request_task_id = UUID(data["requestTaskId"])
        distances = np.asarray(data["distances"])
        sensors_key = data["sensorsKey"]
        sensors_ids = [UUID(item) for item in data["sensorsIds"]]
        sensor_pairs = data["sensorPairs"]
        bounding_area = GeoLocation.from_dict(data["boundingArea"])
        tdoa_heatmap_image = data["tdoaHeatmapImage"]
        return TdoaResponseRecord(
            entry_id=entry_id,
            request_task_id=request_task_id,
            distances=distances,
            sensors_key=sensors_key,
            sensors_ids=sensors_ids,
            sensor_pairs=sensor_pairs,
            bounding_area=bounding_area,
            tdoa_heatmap_image=tdoa_heatmap_image,
        )


@dataclass(frozen=True)
class SpectrumDataRecord:
    """
    Defines a dataclass representing SpectrumDataRecord.schema.json
    """

    __RESPONSE_RECORD_TYPE_CLASS_MAP: ClassVar[dict] = {
        SpectrumDataRecordType.SignalList: ClassificationResponseRecord,
        SpectrumDataRecordType.FreqScanResp: FrequencyResponseRecord,
        SpectrumDataRecordType.IQSnippetResp: IqResponseRecord,
        SpectrumDataRecordType.LOBResp: LobResponseRecord,
        SpectrumDataRecordType.TDOAResp: TdoaResponseRecord,
    }

    record: Union[
        ClassificationResponseRecord,
        FrequencyResponseRecord,
        IqResponseRecord,
        LobResponseRecord,
        TdoaResponseRecord,
    ]

    def __post_init__(self):
        check_object_field(
            self,
            "record",
            (
                ClassificationResponseRecord,
                FrequencyResponseRecord,
                IqResponseRecord,
                LobResponseRecord,
                TdoaResponseRecord,
            ),
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return self.record.to_dict()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SpectrumDataRecord":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        record_type = SpectrumDataRecordType[data["resultType"]]
        record_class = cls.__RESPONSE_RECORD_TYPE_CLASS_MAP[record_type]
        record = record_class.from_dict(data)
        return SpectrumDataRecord(record=record)


@dataclass(frozen=True)
class SpectrumDataMt:
    """
    Defines a dataclass representing SpectrumData_MT.schema.json
    """

    data: SpectrumDataRecord
    request_message_id: Union[UUID, None] = None

    def __post_init__(self):
        check_object_field(self, "data", SpectrumDataRecord)
        check_optional_type(self, "request_message_id", UUID)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {"data": self.data.to_dict()}
        if self.request_message_id is not None:
            data["requestMessageId"] = str(self.request_message_id)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SpectrumDataMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        data_record = SpectrumDataRecord.from_dict(data["data"])
        request_message_id = parse_optional(data, "requestMessageId")
        if request_message_id is not None:
            request_message_id = UUID(request_message_id)
        return SpectrumDataMt(data=data_record, request_message_id=request_message_id)


@dataclass(frozen=True)
class MissionLocation:
    """
    Defines the dataclass for MissionLocation.schema.json
    """

    location_geo: Union[GeoSpatialInfo, None] = None

    def __post_init__(self):
        check_optional_type(self, "location_geo", GeoSpatialInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON
        """
        data = {}
        append_optional_value(
            data=data, field="locationGeo", value=self.location_geo, to_dict_class=True
        )
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MissionLocation":
        """
        Convert Tranche2 compatible JSON

        Parameters
        ----------
        data: Dict[str, Any]
            The dictionary of data to convert
        """
        location_geo = parse_optional(
            data, "locationGeo", from_dict_class=GeoSpatialInfo
        )
        return MissionLocation(
            location_geo=location_geo,
        )


class HeightQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for HeightQuantity unit
    """

    m = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class HeightQuantity:
    """
    Defines the dataclass for HeightQuantity.schema.json
    """

    value: Union[int, float]
    unit: HeightQuantityUnit

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON
        """
        return {
            "value": self.value,
            "unit": str(self.unit),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HeightQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a supplied argument is of the wrong value
        """
        if not isinstance(data["value"], (float, int)):
            raise ValueError("Invalid value: must be a number")
        value = float(data["value"])
        value_unit = data["unit"]
        try:
            unit = HeightQuantityUnit[value_unit]
        except KeyError as exc:
            names = [str(name) for name in FrequencyQuantityUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc
        return HeightQuantity(value=value, unit=unit)


@dataclass(frozen=True)
class Antenna:
    """
    Defines the dataclass for Antenna.schema.json
    """

    antenna_id: UUID
    antenna_height: HeightQuantity

    def __post_init__(self):
        check_object_field(self, "antenna_id", UUID)
        check_object_field(self, "antenna_height", HeightQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "antennaId": str(self.antenna_id),
            "antennaHeight": self.antenna_height.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Antenna":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        antenna_id = UUID(data["antennaId"])
        antenna_height = HeightQuantity.from_dict(data["antennaHeight"])
        return Antenna(antenna_id=antenna_id, antenna_height=antenna_height)


@dataclass(frozen=True)
class RadioEquipment:
    """
    Defines the dataclass for RadioEquipment.schema.json
    """

    radio_equipment_id: UUID
    antenna: Antenna
    serial_number: Union[str, None] = None
    radio_equipment_location: Union[GeoSpatialInfo, None] = None

    def __post_init__(self):
        check_object_field(self, "radio_equipment_id", UUID)
        check_object_field(self, "antenna", Antenna)
        check_optional_type(self, "serial_number", str)
        check_optional_type(self, "radio_equipment_location", GeoSpatialInfo)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "radioEquipmentId": str(self.radio_equipment_id),
            "antenna": self.antenna.to_dict(),
        }

        if self.serial_number is not None:
            data["serialNumber"] = str(self.serial_number)

        if self.radio_equipment_location is not None:
            data["radioEquipmentLocation"] = self.radio_equipment_location.to_dict()

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioEquipment":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        radio_equipment_id = UUID(data["radioEquipmentId"])
        antenna = Antenna.from_dict(data["antenna"])
        serial_number = parse_optional(data, "serialNumber")
        radio_equipment_location = parse_optional(
            data, "radioEquipmentLocation", GeoSpatialInfo
        )

        return RadioEquipment(
            radio_equipment_id=radio_equipment_id,
            antenna=antenna,
            serial_number=serial_number,
            radio_equipment_location=radio_equipment_location,
        )


class FrequencyAssignmentStageUnit(enum.IntEnum):
    """
    Defines valid enumerations for Frequency Assignment stage unit
    """

    # pylint: disable=invalid-name
    assigned = enum.auto()
    draft = enum.auto()
    pending = enum.auto()
    rejected = enum.auto()

    def __str__(self):
        return self.name


class FrequencyListQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for Frequency List Quantity unit field
    """

    # pylint: disable=invalid-name
    MHz = enum.auto()
    GHz = enum.auto()
    Hz = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class FrequencyListQuantity:
    """
    Models FrequencyListQuantity.schema.json
    """

    # pylint: disable=invalid-name

    __scale_factors: ClassVar[Dict[FrequencyListQuantityUnit, float]] = {
        FrequencyListQuantityUnit.Hz: 1,
        FrequencyListQuantityUnit.MHz: 1e6,
        FrequencyListQuantityUnit.GHz: 1e9,
    }

    value: List[Union[float, int]]
    unit: FrequencyListQuantityUnit

    def __post_init__(self):
        check_object_list(self, "value", (float, int), allow_empty=True)
        check_object_field(self, "unit", FrequencyListQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON
        """
        return {"value": self.value, "unit": str(self.unit)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyListQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        unit = parse_enum_from_dict(data, "unit", FrequencyListQuantityUnit)
        return FrequencyListQuantity(value=value, unit=unit)

    def _convert_unit(self, to_unit: FrequencyListQuantityUnit) -> List[float]:
        from_factor = FrequencyListQuantity.__scale_factors[self.unit]
        to_factor = FrequencyListQuantity.__scale_factors[to_unit]
        return [freq * from_factor / to_factor for freq in self.value]

    @property
    def Hz(self) -> List[float]:
        """
        Return the frequency values in Hz
        """
        return self._convert_unit(to_unit=FrequencyListQuantityUnit.Hz)

    @property
    def MHz(self) -> List[float]:
        """
        Return the frequency values in MHz
        """
        return self._convert_unit(to_unit=FrequencyListQuantityUnit.MHz)

    @property
    def GHz(self) -> List[float]:
        """
        Return the frequency values in Hz
        """
        return self._convert_unit(to_unit=FrequencyListQuantityUnit.GHz)


@dataclass(frozen=True)
class FrequencyAssignment:
    requested_frequency_band_start: FrequencyQuantity
    requested_frequency_band_end: FrequencyQuantity
    station_class: str
    requested_emission_designator: str
    stage: FrequencyAssignmentStageUnit
    submitted_by: str
    max_power: PowerQuantity
    agency_serial_number: str
    radio_frequency_allocation: bool
    approved_by: str
    approved_at: dt
    recalled_by: str
    recalled_at: dt
    rejected_by: str
    rejected_at: dt
    frequency_assignment_id: Union[UUID, None] = None
    assigned_frequency: Union[FrequencyListQuantity, None] = None

    def __post_init__(self):
        check_object_field(self, "requested_frequency_band_start", FrequencyQuantity)
        check_object_field(self, "requested_frequency_band_end", FrequencyQuantity)
        check_object_field(self, "station_class", str)
        check_object_field(self, "requested_emission_designator", str)
        check_object_field(self, "stage", FrequencyAssignmentStageUnit)
        check_object_field(self, "submitted_by", str)
        check_object_field(self, "max_power", PowerQuantity)
        check_object_field(self, "agency_serial_number", str)
        check_object_field(self, "radio_frequency_allocation", bool)
        check_object_field(self, "approved_by", str)
        check_object_field(self, "approved_at", dt)
        check_object_field(self, "recalled_by", str)
        check_object_field(self, "recalled_at", dt)
        check_object_field(self, "rejected_by", str)
        check_object_field(self, "rejected_at", dt)
        check_optional_type(self, "frequency_assignment_id", UUID)
        check_optional_type(self, "assigned_frequency", FrequencyListQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "requestedFrequencyBandStart": self.requested_frequency_band_start.to_dict(),
            "requestedFrequencyBandEnd": self.requested_frequency_band_end.to_dict(),
            "stationClass": self.station_class,
            "requestedEmissionDesignator": self.requested_emission_designator,
            "stage": str(self.stage),
            "submittedBy": self.submitted_by,
            "maxPower": self.max_power.to_dict(),
            "agencySerialNumber": self.agency_serial_number,
            "radioFrequencyAllocation": self.radio_frequency_allocation,
            "approvedBy": self.approved_by,
            "approvedAt": get_timestamp_as_str(self.approved_at),
            "recalledBy": self.recalled_by,
            "recalledAt": get_timestamp_as_str(self.recalled_at),
            "rejectedBy": self.rejected_by,
            "rejectedAt": get_timestamp_as_str(self.rejected_at),
        }
        append_optional_value(
            data, "frequencyAssignmentId", self.frequency_assignment_id, to_str=True
        )
        append_optional_value(
            data, "assignedFrequency", self.assigned_frequency, to_dict_class=True
        )

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyAssignment":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        requested_frequency_band_start = parse_optional(
            data, "requestedFrequencyBandStart", FrequencyQuantity
        )
        requested_frequency_band_end = FrequencyQuantity.from_dict(
            data["requestedFrequencyBandEnd"]
        )
        station_class = data["stationClass"]
        requested_emission_designator = data["requestedEmissionDesignator"]
        stage = parse_enum_from_dict(data, "stage", FrequencyAssignmentStageUnit)
        submitted_by = data["submittedBy"]
        max_power = PowerQuantity.from_dict(data["maxPower"])
        agency_serial_number = data["agencySerialNumber"]
        radio_frequency_allocation = data["radioFrequencyAllocation"]
        approved_by = data["approvedBy"]
        approved_at = get_timestamp_from_str(data["approvedAt"])
        recalled_by = data["recalledBy"]
        recalled_at = get_timestamp_from_str(data["recalledAt"])
        rejected_by = data["rejectedBy"]
        rejected_at = get_timestamp_from_str(data["rejectedAt"])
        frequency_assignment_id = parse_optional(data, "frequencyAssignmentId")
        if frequency_assignment_id is not None:
            frequency_assignment_id = UUID(frequency_assignment_id)
        assigned_frequency = parse_optional(
            data, "assignedFrequency", FrequencyListQuantity
        )

        return FrequencyAssignment(
            requested_frequency_band_start=requested_frequency_band_start,
            requested_frequency_band_end=requested_frequency_band_end,
            station_class=station_class,
            requested_emission_designator=requested_emission_designator,
            stage=stage,
            submitted_by=submitted_by,
            max_power=max_power,
            agency_serial_number=agency_serial_number,
            radio_frequency_allocation=radio_frequency_allocation,
            approved_by=approved_by,
            approved_at=approved_at,
            recalled_by=recalled_by,
            recalled_at=recalled_at,
            rejected_by=rejected_by,
            rejected_at=rejected_at,
            frequency_assignment_id=frequency_assignment_id,
            assigned_frequency=assigned_frequency,
        )


class Waveform(enum.IntEnum):
    """
    Defines an enumeration for Waveform.schema.json
    """

    LTE = enum.auto()
    FIVEG_ATW = enum.auto()
    ENG = enum.auto()
    P5_TCTS = enum.auto()
    SRW = enum.auto()

    def __str__(self):
        if self.value == Waveform.FIVEG_ATW:
            return "5G-ATW"
        return self.name.replace("_", "-")

    @classmethod
    def from_str(cls, item: str) -> "Waveform":
        if item == "5G-ATW":
            return Waveform.FIVEG_ATW
        return Waveform[item.replace("-", "_")]


@dataclass(frozen=True)
class Net:
    """
    Defines the dataclass for Net.schema.json
    """

    net_id: UUID
    waveform: Waveform
    radio_count: int
    net_location: GeoSpatialInfo
    policy_set_id: Union[UUID, None] = None
    emitter_list: Union[List[RadioEquipment], None] = None
    receiver_list: Union[List[RadioEquipment], None] = None
    frequency_assignment_list: Union[List[FrequencyAssignment], None] = None

    def __post_init__(self):
        check_object_field(self, "net_id", UUID)
        check_object_field(self, "waveform", Waveform)
        check_object_field(self, "radio_count", int)
        check_object_field(self, "net_location", GeoSpatialInfo)
        check_optional_type(self, "policy_set_id", UUID)
        check_optional_list(self, "emitter_list", RadioEquipment, allow_empty=True)
        check_optional_list(self, "receiver_list", RadioEquipment, allow_empty=True)
        check_optional_list(
            self, "frequency_assignment_list", FrequencyAssignment, allow_empty=True
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "netId": str(self.net_id),
            "waveform": str(self.waveform),
            "radioCount": self.radio_count,
            "netLocation": self.net_location.to_dict(),
        }
        append_optional_value(data, "policySetId", self.policy_set_id, to_str=True)
        append_optional_list(data, "emitterList", self.emitter_list, to_dict_class=True)
        append_optional_list(
            data, "receiverList", self.receiver_list, to_dict_class=True
        )
        append_optional_list(
            data,
            "frequencyAssignmentList",
            self.frequency_assignment_list,
            to_dict_class=True,
        )

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Net":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        net_id = UUID(data["netId"])
        waveform = Waveform.from_str(data["waveform"])
        radio_count = data["radioCount"]
        net_location = GeoSpatialInfo.from_dict(data["netLocation"])
        policy_set_id = parse_optional(data, "policySetId")
        if policy_set_id is not None:
            policy_set_id = UUID(policy_set_id)
        emitter_list = parse_optional_list(data, "emitterList", RadioEquipment)
        receiver_list = parse_optional_list(data, "receiverList", RadioEquipment)
        frequency_assignment_list = parse_optional_list(
            data, "frequencyAssignmentList", FrequencyAssignment
        )

        return Net(
            net_id=net_id,
            waveform=waveform,
            radio_count=radio_count,
            net_location=net_location,
            policy_set_id=policy_set_id,
            emitter_list=emitter_list,
            receiver_list=receiver_list,
            frequency_assignment_list=frequency_assignment_list,
        )


@dataclass(frozen=True)
class MissionPlan:
    """
    Defines the dataclass for MissionPlan.schema.json
    """

    mission_id: UUID
    mission_unit: str
    mission_location: MissionLocation
    mission_time: DayTimePeriod
    net_list: List[Net]
    mission_name: Union[str, None] = None

    def __post_init__(self):
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "mission_unit", str)
        check_object_field(self, "mission_location", MissionLocation)
        check_object_field(self, "mission_time", DayTimePeriod)
        check_object_list(self, "net_list", Net, allow_empty=True)
        check_optional_type(self, "mission_name", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "missionId": str(self.mission_id),
            "missionUnit": self.mission_unit,
            "missionLocation": self.mission_location.to_dict(),
            "missionTime": self.mission_time.to_dict(),
            "netList": [obj.to_dict() for obj in self.net_list],
        }
        append_optional_value(data, "missionName", self.mission_name)

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MissionPlan":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_id = UUID(data["missionId"])
        mission_unit = data["missionUnit"]
        mission_location = MissionLocation.from_dict(data["missionLocation"])
        mission_time = DayTimePeriod.from_dict(data["missionTime"])
        net_list = [Net.from_dict(obj) for obj in data["netList"]]
        mission_name = parse_optional(data, "missionName")

        return MissionPlan(
            mission_id=mission_id,
            mission_unit=mission_unit,
            mission_location=mission_location,
            mission_time=mission_time,
            net_list=net_list,
            mission_name=mission_name,
        )


class ModulationUnit(enum.IntEnum):
    """
    Defines valid enumerations for Transmitter Characteristics modulation field
    """

    DSB_SC = enum.auto()
    SSB = enum.auto()
    SSC_SC = enum.auto()
    VSB = enum.auto()
    FM = enum.auto()
    PM = enum.auto()
    BPSK = enum.auto()
    QPSK = enum.auto()
    M_PSK = enum.auto()
    MSK = enum.auto()
    GMSK = enum.auto()
    CPFSK = enum.auto()
    M_FSK = enum.auto()
    OOK = enum.auto()
    M_ASK = enum.auto()
    M_QAM = enum.auto()
    OFDM = enum.auto()
    DSSS = enum.auto()
    FHSS = enum.auto()
    PPM = enum.auto()
    M_VSB = enum.auto()

    def __str__(self):
        if "_" in str(self.name):
            return str(self.name).replace("_", "-")
        return self.name


class ForwardErrorCorrectionUnit(enum.IntEnum):
    """
    Defines the valid enumerations for Transmitter Characteristics Forward Error Correction field
    """

    Block = enum.auto()
    Golay = enum.auto()
    RS = enum.auto()
    Conv = enum.auto()
    Turbo = enum.auto()
    LDPC = enum.auto()
    Polar = enum.auto()

    def __str__(self):
        return self.name


class FecRateUnit(enum.IntEnum):
    """
    Defines valid enumerations for Transmitter Characteristics FEC Rate Unit
    """

    FEC_1_6 = enum.auto()
    FEC_1_5 = enum.auto()
    FEC_1_3 = enum.auto()
    FEC_1_4 = enum.auto()
    FEC_1_2 = enum.auto()
    FEC_2_3 = enum.auto()
    FEC_3_4 = enum.auto()
    FEC_4_5 = enum.auto()
    FEC_5_6 = enum.auto()
    FEC_6_7 = enum.auto()
    FEC_223_255 = enum.auto()
    FEC_7_8 = enum.auto()
    FEC_7_4 = enum.auto()
    FEC_8_4 = enum.auto()

    def __str__(self):
        return str(self.name).replace("FEC_", "").replace("_", "/")


class MacProtocolUnit(enum.IntEnum):
    """
    Defines valid enumerations for Mac Protocol Unit
    """

    FDMA = enum.auto()
    TDMA = enum.auto()
    MC_TDMA = enum.auto()
    CDMA = enum.auto()
    CSMA = enum.auto()
    SPMA = enum.auto()
    OFDM = enum.auto()

    def __str__(self):
        if "_" in str(self.name):
            return str(self.name).replace("_", "-")
        return self.name


@dataclass(frozen=True)
class TransmitPowerRange:
    """
    Defines the dataclass for TransmitPowerRange.schema.json
    """

    low_power: Union[PowerQuantity, None]
    high_power: Union[PowerQuantity, None]

    def __post_init__(self):
        check_optional_type(self, "low_power", PowerQuantity)
        check_optional_type(self, "high_power", PowerQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON
        """
        data = {}

        if self.low_power is not None:
            data["lowPower"] = self.low_power.to_dict()

        if self.high_power is not None:
            data["highPower"] = self.high_power.to_dict()

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TransmitPowerRange":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        low_power = parse_optional(data, "lowPower", PowerQuantity)
        high_power = parse_optional(data, "highPower", PowerQuantity)

        return TransmitPowerRange(low_power=low_power, high_power=high_power)


@dataclass(frozen=True)
class BandwidthRange:
    """
    Defines the dataclass for BandwidthRange.schema.json
    """

    low_bandwidth: Union[FrequencyQuantity, None]
    high_bandwidth: Union[FrequencyQuantity, None]

    def __post_init__(self):
        check_optional_type(self, "low_bandwidth", FrequencyQuantity)
        check_optional_type(self, "high_bandwidth", FrequencyQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}

        if self.low_bandwidth is not None:
            data["lowBandwidth"] = self.low_bandwidth.to_dict()

        if self.high_bandwidth is not None:
            data["highBandwidth"] = self.high_bandwidth.to_dict()

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BandwidthRange":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        low_bandwidth = parse_optional(data, "lowBandwidth", FrequencyQuantity)
        high_bandwidth = parse_optional(data, "highBandwidth", FrequencyQuantity)

        return BandwidthRange(
            low_bandwidth=low_bandwidth, high_bandwidth=high_bandwidth
        )


@dataclass(frozen=True)
class TransmitterCharacteristics:
    """
    Defines the dataclass for TransmitterCharacteristics.schema.json
    """

    frequency_range: Union[FrequencyBand, None]
    transmit_power_range: Union[TransmitPowerRange, None]
    occupied_bandwidth: Union[BandwidthRange, None]
    modulation: ModulationUnit
    forward_error_correction: ForwardErrorCorrectionUnit
    fec_rate: FecRateUnit
    mac_protocol: MacProtocolUnit

    def __post_init__(self):
        check_optional_type(self, "frequency_range", FrequencyBand)
        check_optional_type(self, "transmit_power_range", TransmitPowerRange)
        check_optional_type(self, "occupied_bandwidth", BandwidthRange)
        check_object_field(self, "modulation", ModulationUnit)
        check_object_field(self, "forward_error_correction", ForwardErrorCorrectionUnit)
        check_object_field(self, "fec_rate", FecRateUnit)
        check_object_field(self, "mac_protocol", MacProtocolUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "modulation": str(self.modulation),
            "forwardErrorCorrection": str(self.forward_error_correction),
            "FECRate": str(self.fec_rate),
            "MACProtocol": str(self.mac_protocol),
        }

        if self.frequency_range is not None:
            data["frequencyRange"] = self.frequency_range.to_dict()

        if self.transmit_power_range is not None:
            data["transmitPowerRange"] = self.transmit_power_range.to_dict()

        if self.occupied_bandwidth is not None:
            data["occupiedBandwidth"] = self.occupied_bandwidth.to_dict()

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TransmitterCharacteristics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        frequency_range = parse_optional(data, "frequencyRange", FrequencyBand)
        transmit_power_range = parse_optional(
            data, "transmitPowerRange", TransmitPowerRange
        )
        occupied_bandwidth = parse_optional(data, "occupiedBandwidth", BandwidthRange)
        modulation_unit = data["modulation"]
        try:
            modulation_unit = modulation_unit.replace("-", "_")
            modulation = ModulationUnit[modulation_unit]
        except KeyError as exc:
            names = [str(name) for name in ModulationUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        forward_error_correction_unit = data["forwardErrorCorrection"]
        try:
            forward_error_correction = ForwardErrorCorrectionUnit[
                forward_error_correction_unit
            ]
        except KeyError as exc:
            names = [str(name) for name in ForwardErrorCorrectionUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        fec_rate_unit = data["FECRate"]
        try:
            fec_rate_unit = f"FEC_{'_'.join(fec_rate_unit.split('/'))}"
            fec_rate = FecRateUnit[fec_rate_unit]
        except KeyError as exc:
            names = [str(name) for name in FecRateUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        mac_protocol_unit = data["MACProtocol"]
        try:
            mac_protocol_unit = mac_protocol_unit.replace("-", "_")
            mac_protocol = MacProtocolUnit[mac_protocol_unit]
        except KeyError as exc:
            names = [str(name) for name in MacProtocolUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        return TransmitterCharacteristics(
            frequency_range=frequency_range,
            transmit_power_range=transmit_power_range,
            occupied_bandwidth=occupied_bandwidth,
            modulation=modulation,
            forward_error_correction=forward_error_correction,
            fec_rate=fec_rate,
            mac_protocol=mac_protocol,
        )


class ReceiverSensitivityQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for Receiver Sensitivity Quantity unit
    """

    dBm = enum.auto()

    def __str__(self):
        return self.name


class NoiseFigureQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for Noise Figure Quantity unit
    """

    dB = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class ReceiverSensitivityQuantity:
    """
    Defines the dataclass for ReceiverSensitivityQuantity.schema.json
    """

    value: Union[int, float]
    unit: ReceiverSensitivityQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (int, float))
        check_object_field(self, "unit", ReceiverSensitivityQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"value": self.value, "unit": str(self.unit)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ReceiverSensitivityQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        value = data["value"]

        value_unit = data["unit"]
        try:
            unit = ReceiverSensitivityQuantityUnit[value_unit]
        except KeyError as exc:
            names = [str(name) for name in ReceiverSensitivityQuantityUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        return ReceiverSensitivityQuantity(value=value, unit=unit)


@dataclass(frozen=True)
class NoiseFigureQuantity:
    """
    Defines the dataclass for NoiseFigureQuantity.schema.json
    """

    value: Union[int, float]
    unit: NoiseFigureQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (int, float))
        check_object_field(self, "unit", NoiseFigureQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"value": self.value, "unit": str(self.unit)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NoiseFigureQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        value = data["value"]

        value_unit = data["unit"]
        try:
            unit = NoiseFigureQuantityUnit[value_unit]
        except KeyError as exc:
            names = [str(name) for name in NoiseFigureQuantityUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        return NoiseFigureQuantity(value=value, unit=unit)


@dataclass(frozen=True)
class ReceiverCharacteristics:
    """
    Defines the dataclass for ReceiverCharacteristics.schema.json
    """

    frequency_range: Union[FrequencyBand, None]
    sensitivity: Union[ReceiverSensitivityQuantity, None]
    noise_figure: Union[NoiseFigureQuantity, None]

    def __post_init__(self):
        check_optional_type(self, "frequency_range", FrequencyBand)
        check_optional_type(self, "sensitivity", ReceiverSensitivityQuantity)
        check_optional_type(self, "noise_figure", NoiseFigureQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}

        if self.frequency_range is not None:
            data["frequencyRange"] = self.frequency_range.to_dict()

        if self.sensitivity is not None:
            data["sensitivity"] = self.sensitivity.to_dict()

        if self.noise_figure is not None:
            data["noiseFigure"] = self.noise_figure.to_dict()

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ReceiverCharacteristics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        frequency_range = parse_optional(data, "frequencyRange", FrequencyBand)
        sensitivity = parse_optional(data, "sensitivity", ReceiverSensitivityQuantity)
        noise_figure = parse_optional(data, "noiseFigure", NoiseFigureQuantity)

        return ReceiverCharacteristics(
            frequency_range=frequency_range,
            sensitivity=sensitivity,
            noise_figure=noise_figure,
        )


class PolarizationUnit(enum.IntEnum):
    """
    Defines valid enumerations for AntennaCharacteristics polarization field
    """

    vertical = enum.auto()
    horizontal = enum.auto()
    slant = enum.auto()
    RHC = enum.auto()
    LHC = enum.auto()
    elliptical = enum.auto()

    def __str__(self):
        return self.name


class BeamwidthQuantityUnit(enum.IntEnum):
    """
    Defines valid enumerations for BeamwidthQuantityUnit
    """

    deg = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class BeamwidthQuantity:
    """
    Defines the dataclass for BeamwidthQuantity.schema.json
    """

    value: Union[int, float]
    unit: BeamwidthQuantityUnit

    def __post_init__(self):
        check_object_field(self, "value", (int, float))
        check_object_field(self, "unit", BeamwidthQuantityUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON
        """
        return {"value": self.value, "unit": str(self.unit)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BeamwidthQuantity":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        value = data["value"]
        value_unit = data["unit"]
        try:
            unit = BeamwidthQuantityUnit[value_unit]
        except KeyError as exc:
            names = [str(name) for name in BeamwidthQuantityUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        return BeamwidthQuantity(value=value, unit=unit)


@dataclass(frozen=True)
class AntennaCharacteristics:
    """
    Defines the dataclass for AntennaCharacteristics.schema.json
    """

    antenna_type: str
    low_frequency: FrequencyQuantity
    high_frequency: FrequencyQuantity
    main_beam_gain: GainQuantity
    side_lobe_gain: GainQuantity
    horizontal_beamwidth: BeamwidthQuantity
    vertical_beamwidth: BeamwidthQuantity
    azimuth: AngleQuantity
    polarization: PolarizationUnit

    def __post_init__(self):
        check_object_field(self, "antenna_type", str)
        check_object_field(self, "low_frequency", FrequencyQuantity)
        check_object_field(self, "high_frequency", FrequencyQuantity)
        check_object_field(self, "main_beam_gain", GainQuantity)
        check_object_field(self, "side_lobe_gain", GainQuantity)
        check_object_field(self, "horizontal_beamwidth", BeamwidthQuantity)
        check_object_field(self, "vertical_beamwidth", BeamwidthQuantity)
        check_object_field(self, "azimuth", AngleQuantity)
        check_object_field(self, "polarization", PolarizationUnit)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "antennaType": self.antenna_type,
            "lowFrequency": self.low_frequency.to_dict(),
            "highFrequency": self.high_frequency.to_dict(),
            "mainBeamGain": self.main_beam_gain.to_dict(),
            "sideLobeGain": self.side_lobe_gain.to_dict(),
            "horizontalBeamwidth": self.horizontal_beamwidth.to_dict(),
            "verticalBeamwidth": self.vertical_beamwidth.to_dict(),
            "azimuth": self.azimuth.to_dict(),
            "polarization": str(self.polarization),
        }

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AntennaCharacteristics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        antenna_type = data["antennaType"]
        low_frequency = FrequencyQuantity.from_dict(data["lowFrequency"])
        high_frequency = FrequencyQuantity.from_dict(data["highFrequency"])
        main_beam_gain = GainQuantity.from_dict(data["mainBeamGain"])
        side_lobe_gain = GainQuantity.from_dict(data["sideLobeGain"])
        horizontal_beamwidth = BeamwidthQuantity.from_dict(data["horizontalBeamwidth"])
        vertical_beamwidth = BeamwidthQuantity.from_dict(data["verticalBeamwidth"])
        azimuth = AngleQuantity.from_dict(data["azimuth"])
        polarization_type = data["polarization"]
        try:
            polarization = PolarizationUnit[polarization_type]
        except KeyError as exc:
            names = [str(name) for name in PolarizationUnit]
            raise ValueError(f"Invalid unit: must be one of {names}") from exc

        return AntennaCharacteristics(
            antenna_type=antenna_type,
            low_frequency=low_frequency,
            high_frequency=high_frequency,
            main_beam_gain=main_beam_gain,
            side_lobe_gain=side_lobe_gain,
            horizontal_beamwidth=horizontal_beamwidth,
            vertical_beamwidth=vertical_beamwidth,
            azimuth=azimuth,
            polarization=polarization,
        )


@dataclass(frozen=True)
class RadioData:
    """
    Defines a dataclass describing RadioData.schema.json
    """

    radio_equipment_id: UUID
    transmitter_characteristics: Union[TransmitterCharacteristics, None]
    receiver_characteristics: Union[ReceiverCharacteristics, None]
    antenna_characteristics: Union[AntennaCharacteristics, None]

    def __post_init__(self):
        check_object_field(self, "radio_equipment_id", UUID)
        check_optional_type(
            self, "transmitter_characteristics", TransmitterCharacteristics
        )
        check_optional_type(self, "receiver_characteristics", ReceiverCharacteristics)
        check_optional_type(self, "antenna_characteristics", AntennaCharacteristics)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "radioEquipmentId": str(self.radio_equipment_id),
        }
        if self.transmitter_characteristics is not None:
            data[
                "transmitterCharacteristics"
            ] = self.transmitter_characteristics.to_dict()

        if self.receiver_characteristics is not None:
            data["receiverCharacteristics"] = self.receiver_characteristics.to_dict()

        if self.antenna_characteristics is not None:
            data["antennaCharacteristics"] = self.antenna_characteristics.to_dict()

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioData":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        radio_equipment_id = UUID(data["radioEquipmentId"])
        transmitter_characteristics = parse_optional(
            data, "transmitterCharacteristics", TransmitterCharacteristics
        )
        receiver_characteristics = parse_optional(
            data, "receiverCharacteristics", ReceiverCharacteristics
        )
        antenna_characteristics = parse_optional(
            data, "antennaCharacteristics", AntennaCharacteristics
        )

        return RadioData(
            radio_equipment_id=radio_equipment_id,
            transmitter_characteristics=transmitter_characteristics,
            receiver_characteristics=receiver_characteristics,
            antenna_characteristics=antenna_characteristics,
        )


@dataclass(frozen=True)
class PolicyDataRisa:
    """
    Defines the dataclass for PolicyDataRisa.schema.json
    """

    policy_set_id: UUID
    policy_list: List[NetworkPolicy]

    def __post_init__(self):
        check_object_field(self, "policy_set_id", UUID)
        check_object_list(self, "policy_list", NetworkPolicy, False)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "policySetId": str(self.policy_set_id),
            "policyList": [obj.to_dict() for obj in self.policy_list],
        }
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyDataRisa":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        policy_set_id = UUID(data["policySetId"])
        policy_list = [NetworkPolicy.from_dict(obj) for obj in data["policyList"]]

        return PolicyDataRisa(policy_set_id=policy_set_id, policy_list=policy_list)


@dataclass(frozen=True)
class MissionPlanDescriptorMt:
    """
    Defines a dataclass describing MissionPlanDescriptor_MT.schema.json
    """

    mission_plans: List[MissionPlan]
    radio_data: List[RadioData]
    policy_data: List[PolicyDataRisa]
    request_message_id: Union[UUID, None] = None

    def __post_init__(self):
        check_object_list(self, "mission_plans", MissionPlan, allow_empty=True)
        check_object_list(self, "radio_data", RadioData, allow_empty=True)
        check_object_list(self, "policy_data", PolicyDataRisa, allow_empty=True)
        check_optional_type(self, "request_message_id", UUID)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "missionPlans": to_dict_list(self.mission_plans),
            "radioData": to_dict_list(self.radio_data),
            "policyData": to_dict_list(self.policy_data),
        }
        append_optional_value(
            data, "requestMessageId", self.request_message_id, to_str=True
        )
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MissionPlanDescriptorMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        ValueError
            If a value is missing
        """
        mission_plans = from_dict_list(data["missionPlans"], MissionPlan)
        radio_data = from_dict_list(data["radioData"], RadioData)
        policy_data = from_dict_list(data["policyData"], PolicyDataRisa)
        request_message_id = parse_optional(data, "requestMessageId")
        if request_message_id is not None:
            request_message_id = UUID(request_message_id)

        return MissionPlanDescriptorMt(
            mission_plans=mission_plans,
            radio_data=radio_data,
            policy_data=policy_data,
            request_message_id=request_message_id,
        )


class NetStatus(enum.IntEnum):
    """
    Models NetPlan.schema.json netStatus enum
    """

    # pylint: disable=invalid-name
    pre_deploy = enum.auto()
    deploying = enum.auto()
    deployed = enum.auto()
    starting = enum.auto()
    started = enum.auto()
    pre_active = enum.auto()
    active = enum.auto()
    active_hold = enum.auto()
    deploy_failed = enum.auto()
    start_failed = enum.auto()
    expired = enum.auto()

    def __str__(self):
        return self.name.replace("_", "-")

    @classmethod
    def from_str(cls, item: str):
        """Convert a string into a NetStatus"""
        return NetStatus[item.replace("-", "_")]


@dataclass(frozen=True)
class NetPlan:
    """
    Defines a dataclass representing NetPlan.schema.json
    """

    net_id: UUID
    net_name: str
    net_status_time: dt
    net_status: NetStatus
    min_radio_count: int
    actual_radio_count: int
    radios: List[str]

    def __post_init__(self):
        check_object_field(self, "net_id", UUID)
        check_object_field(self, "net_name", str)
        check_object_field(self, "net_status_time", dt)
        check_object_field(self, "net_status", NetStatus)
        check_object_field(self, "min_radio_count", int)
        check_object_field(self, "actual_radio_count", int)
        check_object_list(self, "radios", str, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "netId": str(self.net_id),
            "netName": self.net_name,
            "netStatusTime": get_timestamp_as_str(self.net_status_time),
            "netStatus": str(self.net_status),
            "minRadioCount": self.min_radio_count,
            "actualRadioCount": self.actual_radio_count,
            "radios": self.radios,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "NetPlan":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        net_id = UUID(data["netId"])
        net_name = data["netName"]
        net_status_time = get_timestamp_from_str(data["netStatusTime"])
        net_status = NetStatus.from_str(data["netStatus"])
        min_radio_count = data["minRadioCount"]
        actual_radio_count = data["actualRadioCount"]
        radios = data["radios"]

        return NetPlan(
            net_id=net_id,
            net_name=net_name,
            net_status_time=net_status_time,
            net_status=net_status,
            min_radio_count=min_radio_count,
            actual_radio_count=actual_radio_count,
            radios=radios,
        )


class PlanStatus(enum.IntEnum):
    """
    Models ActivePlan.schema.json planStatus enum
    """

    # pylint: disable=invalid-name
    pre_deploy = enum.auto()
    deploying = enum.auto()
    deployed = enum.auto()
    starting = enum.auto()
    started = enum.auto()
    pre_active = enum.auto()
    active = enum.auto()
    active_hold = enum.auto()
    deploy_failed = enum.auto()
    start_failed = enum.auto()
    expired = enum.auto()

    def __str__(self):
        return self.name.replace("_", "-")

    @classmethod
    def from_str(cls, item: str):
        """Convert a string into an ActivePlanStatus"""
        return PlanStatus[item.replace("-", "_")]


@dataclass(frozen=True)
class ActivePlan:
    """
    Defines a dataclass representing ActivePlan.schema.json
    """

    mission_id: UUID
    mission_name: str
    plan_id: UUID
    plan_name: str
    plan_receive_time: dt
    plan_status_time: dt
    plan_status: PlanStatus
    net_plans: List[NetPlan]

    def __post_init__(self):
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "mission_name", str)
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)
        check_object_field(self, "plan_receive_time", dt)
        check_object_field(self, "plan_status_time", dt)
        check_object_field(self, "plan_status", PlanStatus)
        check_object_list(self, "net_plans", NetPlan, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "missionId": str(self.mission_id),
            "missionName": self.mission_name,
            "planId": str(self.plan_id),
            "planName": self.plan_name,
            "planReceiveTime": get_timestamp_as_str(self.plan_receive_time),
            "planStatusTime": get_timestamp_as_str(self.plan_status_time),
            "planStatus": str(self.plan_status),
            "netPlans": to_dict_list(self.net_plans),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ActivePlan":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_id = UUID(data["missionId"])
        mission_name = data["missionName"]
        plan_id = UUID(data["planId"])
        plan_name = data["planName"]
        plan_receive_time = get_timestamp_from_str(data["planReceiveTime"])
        plan_status_time = get_timestamp_from_str(data["planStatusTime"])
        plan_status = PlanStatus.from_str(data["planStatus"])
        net_plans = from_dict_list(data["netPlans"], NetPlan)

        return ActivePlan(
            mission_id=mission_id,
            mission_name=mission_name,
            plan_id=plan_id,
            plan_name=plan_name,
            plan_receive_time=plan_receive_time,
            plan_status_time=plan_status_time,
            plan_status=plan_status,
            net_plans=net_plans,
        )


@dataclass(frozen=True)
class ActivePlansReportMt:
    """
    Defines a dataclass representing ActivePlansReport_MT.schema.json.
    """

    request_message_id: UUID
    plans: List[ActivePlan]

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_list(self, "plans", ActivePlan)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "plans": to_dict_list(self.plans),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ActivePlansReportMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        plans = from_dict_list(data["plans"], ActivePlan)

        return ActivePlansReportMt(request_message_id=request_message_id, plans=plans)


@dataclass(frozen=True)
class ActivePlansRequestMt:
    """
    Defines a dataclass representing ActivePlansRequest_MT.schema.json.
    """

    detailed: bool

    def __post_init__(self):
        check_object_field(self, "detailed", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"detailed": self.detailed}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ActivePlansRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        detailed = data["detailed"]
        return ActivePlansRequestMt(detailed=detailed)


@dataclass(frozen=True)
class Report:
    """
    Defines the dataclass representing Report.schema.json
    """

    radio_serial_number: str
    mission_id: UUID
    mission_name: str
    plan_id: UUID
    plan_name: str
    plan_receive_time: dt
    plan_status: PlanStatus
    plan_status_time: dt
    net_id: UUID
    net_name: str
    net_status_time: dt
    net_status: NetStatus
    expected_attempts_1hr: int
    actual_results_1hr: int
    last_radio_communication: dt

    def __post_init__(self):
        check_object_field(self, "radio_serial_number", str)
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "mission_name", str)
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)
        check_object_field(self, "plan_receive_time", dt)
        check_object_field(self, "plan_status", PlanStatus)
        check_object_field(self, "plan_status_time", dt)
        check_object_field(self, "net_id", UUID)
        check_object_field(self, "net_name", str)
        check_object_field(self, "net_status_time", dt)
        check_object_field(self, "net_status", NetStatus)
        check_object_field(self, "expected_attempts_1hr", int)
        check_object_field(self, "actual_results_1hr", int)
        check_object_field(self, "last_radio_communication", dt)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "radioSerialNumber": self.radio_serial_number,
            "missionId": str(self.mission_id),
            "missionName": self.mission_name,
            "planId": str(self.plan_id),
            "planName": self.plan_name,
            "planReceiveTime": get_timestamp_as_str(self.plan_receive_time),
            "planStatus": str(self.plan_status),
            "planStatusTime": get_timestamp_as_str(self.plan_status_time),
            "netId": str(self.net_id),
            "netName": self.net_name,
            "netStatusTime": get_timestamp_as_str(self.net_status_time),
            "netStatus": str(self.net_status),
            "expectedAttempts_1hr": self.expected_attempts_1hr,
            "actualResults_1hr": self.actual_results_1hr,
            "lastRadioCommunication": get_timestamp_as_str(
                self.last_radio_communication
            ),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Report":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        radio_serial_number = data["radioSerialNumber"]
        mission_id = UUID(data["missionId"])
        mission_name = data["missionName"]
        plan_id = UUID(data["planId"])
        plan_name = data["planName"]
        plan_receive_time = get_timestamp_from_str(data["planReceiveTime"])
        plan_status = PlanStatus.from_str(data["planStatus"])
        plan_status_time = get_timestamp_from_str(data["planStatusTime"])
        net_id = UUID(data["netId"])
        net_name = data["netName"]
        net_status_time = get_timestamp_from_str(data["netStatusTime"])
        net_status = NetStatus.from_str(data["netStatus"])
        expected_attempts_1hr = data["expectedAttempts_1hr"]
        actual_results_1hr = data["actualResults_1hr"]
        last_radio_communication = get_timestamp_from_str(
            data["lastRadioCommunication"]
        )

        return Report(
            radio_serial_number=radio_serial_number,
            mission_id=mission_id,
            mission_name=mission_name,
            plan_id=plan_id,
            plan_name=plan_name,
            plan_receive_time=plan_receive_time,
            plan_status=plan_status,
            plan_status_time=plan_status_time,
            net_id=net_id,
            net_name=net_name,
            net_status_time=net_status_time,
            net_status=net_status,
            expected_attempts_1hr=expected_attempts_1hr,
            actual_results_1hr=actual_results_1hr,
            last_radio_communication=last_radio_communication,
        )


@dataclass(frozen=True)
class HeartbeatReportMt:
    """
    Defines a dataclass representing HeartbeatReport_MT.schema.json.
    """

    heartbeat_report: Union[List[Report], None] = None

    def __post_init__(self):
        check_optional_list(self, "heartbeat_report", Report, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {}

        if self.heartbeat_report is not None:
            data["heartbeatReport"] = to_dict_list(self.heartbeat_report)

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HeartbeatReportMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        heartbeat_report = parse_optional_list(data, "heartbeatReport", Report)

        return HeartbeatReportMt(heartbeat_report=heartbeat_report)


@dataclass(frozen=True)
class HeartbeatRequestMt:
    """
    Defines a dataclass representing HeartbeatRequest_MT.schema.json.
    """

    detailed: bool

    def __post_init__(self):
        check_object_field(self, "detailed", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"detailed": self.detailed}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HeartbeatRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        detailed = data["detailed"]
        return HeartbeatRequestMt(detailed=detailed)


@dataclass(frozen=True)
class TimeRule:
    """
    Defines the dataclass for TimeRule.schema.json
    """

    time_periods: List[DayTimePeriod]

    def __post_init__(self):
        check_object_list(self, "time_periods", DayTimePeriod, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {"timePeriods": to_dict_list(self.time_periods)}

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TimeRule":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        time_periods = from_dict_list(data["timePeriods"], DayTimePeriod)

        return TimeRule(time_periods=time_periods)


class GeoSpatialRuleShape(enum.IntEnum):
    """
    Defines valid shapes for GeoSpatialRule.schema.json.
    """

    # pylint: disable=invalid-name
    circle = enum.auto()
    polygon = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class GeoSpatialRuleCircle:
    """
    Defines a dataclass representing GeoSpatialRule.schema.json's circle.
    """

    feature: GeoJsonFeature
    altitude: DistanceQuantity
    radius: DistanceQuantity

    def __post_init__(self):
        check_object_field(self, "feature", GeoJsonFeature)
        check_object_field(self.feature, "geometry", GeoJsonPoint)
        check_object_field(self, "altitude", DistanceQuantity)
        check_object_field(self, "radius", DistanceQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "shape": str(GeoSpatialRuleShape.circle),
            "feature": self.feature.to_dict(),
            "altitude": self.altitude.to_dict(),
            "radius": self.radius.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoSpatialRuleCircle":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        shape = data["shape"]
        if shape != str(GeoSpatialRuleShape.circle):
            raise ValueError(
                f"Attempting to convert non-circle {shape} to {GeoSpatialRuleShape.circle}"
            )
        feature = GeoJsonFeature.from_dict(data["feature"])
        altitude = DistanceQuantity.from_dict(data["altitude"])
        radius = DistanceQuantity.from_dict(data["radius"])
        return GeoSpatialRuleCircle(feature=feature, altitude=altitude, radius=radius)


@dataclass(frozen=True)
class GeoSpatialRulePolygon:
    """
    Defines a dataclass representing GeoSpatialRule.schema.json's polygon.
    """

    feature: GeoJsonFeature
    altitude: DistanceQuantity

    def __post_init__(self):
        check_object_field(self, "feature", GeoJsonFeature)
        check_object_field(self.feature, "geometry", GeoJsonPolygon)
        check_object_field(self, "altitude", DistanceQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "shape": str(GeoSpatialRuleShape.polygon),
            "feature": self.feature.to_dict(),
            "altitude": self.altitude.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoSpatialRulePolygon":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        shape = data["shape"]
        if shape != str(GeoSpatialRuleShape.polygon):
            raise ValueError(
                f"Attempting to convert non-polygon {shape} to {str(GeoSpatialRuleShape.polygon)}"
            )
        feature = GeoJsonFeature.from_dict(data["feature"])
        altitude = DistanceQuantity.from_dict(data["altitude"])
        return GeoSpatialRulePolygon(feature=feature, altitude=altitude)


@dataclass(frozen=True)
class GeoSpatialRule:
    """
    Defines a dataclass representing a GeoSpatialRule.schema.json.
    """

    __SHAPE_TYPE_CLASS_MAP: ClassVar[dict] = {
        str(GeoSpatialRuleShape.circle): GeoSpatialRuleCircle,
        str(GeoSpatialRuleShape.polygon): GeoSpatialRulePolygon,
    }
    __ALLOWED_TYPES: ClassVar[tuple] = (GeoSpatialRuleCircle, GeoSpatialRulePolygon)

    shape: Union[GeoSpatialRuleCircle, GeoSpatialRulePolygon]

    @property
    def shape_type(self) -> GeoSpatialRuleShape:
        """
        Return the type of the GeoSpatialInfo shape.
        """
        if isinstance(self.shape, GeoSpatialRuleCircle):
            return GeoSpatialRuleShape.circle
        elif isinstance(self.shape, GeoSpatialRulePolygon):
            return GeoSpatialRuleShape.polygon
        return None

    def __post_init__(self):
        check_object_field(self, "shape", GeoSpatialRule.__ALLOWED_TYPES)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return self.shape.to_dict()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeoSpatialRule":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        shape_type = data["shape"]
        shape_class: Union[
            GeoSpatialRuleCircle, GeoSpatialRulePolygon
        ] = cls.__SHAPE_TYPE_CLASS_MAP[shape_type]
        shape = shape_class.from_dict(data)
        return GeoSpatialRule(shape=shape)


@dataclass(frozen=True)
class FrequencyRule:
    """
    Defines the dataclass for FrequencyRule.schema.json
    """

    all_freqs: bool
    freq_ranges: Union[List[FrequencyBand], None] = None

    def __post_init__(self):
        check_object_field(self, "all_freqs", bool)
        check_optional_list(self, "freq_ranges", FrequencyBand, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {"allFreqs": self.all_freqs}
        append_optional_list(data, "freqRanges", self.freq_ranges, to_dict_class=True)

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FrequencyRule":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        all_freqs = data["allFreqs"]
        freq_ranges = parse_optional_list(data, "freqRanges", FrequencyBand)

        return FrequencyRule(all_freqs=all_freqs, freq_ranges=freq_ranges)


@dataclass(frozen=True)
class PolicyRuleset:
    """
    Defines the dataclass for PolicyRuleset.schema.json
    """

    frequency_rule: FrequencyRule
    geospatial_rule: Union[GeoSpatialRule, None] = None
    time_rule: Union[TimeRule, None] = None

    def __post_init__(self):
        check_object_field(self, "frequency_rule", FrequencyRule)
        check_optional_type(self, "geospatial_rule", GeoSpatialRule)
        check_optional_type(self, "time_rule", TimeRule)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {"frequencyRule": self.frequency_rule.to_dict()}
        append_optional_value(
            data, "geospatialRule", self.geospatial_rule, to_dict_class=True
        )
        append_optional_value(data, "timeRule", self.time_rule, to_dict_class=True)

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyRuleset":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        frequency_rule = FrequencyRule.from_dict(data["frequencyRule"])
        geospatial_rule = parse_optional(data, "geospatialRule", GeoSpatialRule)
        time_rule = parse_optional(data, "timeRule", TimeRule)

        return PolicyRuleset(
            frequency_rule=frequency_rule,
            geospatial_rule=geospatial_rule,
            time_rule=time_rule,
        )


@dataclass(frozen=True)
class PolicyOrganization:
    """
    Defines the dataclass for PolicyOrganization.schema.json
    """

    name: str

    def __post_init__(self):
        check_object_field(self, "name", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"name": self.name}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyOrganization":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        name = data["name"]

        return PolicyOrganization(name=name)


@dataclass(frozen=True)
class PolicyProps:
    """
    Defines the dataclass for PolicyProps.schema.json
    """

    id: UUID
    policy_name: str
    version: str
    priority: int
    permissive: bool
    description: str
    issuing_organization: Union[PolicyOrganization, None] = None
    rulesets: Union[List[PolicyRuleset], None] = None

    def __post_init__(self):
        check_object_field(self, "id", UUID)
        check_object_field(self, "policy_name", str)
        check_object_field(self, "version", str)
        check_object_field(self, "priority", int)
        check_object_field(self, "permissive", bool)
        check_object_field(self, "description", str)
        check_optional_type(self, "issuing_organization", PolicyOrganization)
        check_optional_list(self, "rulesets", PolicyRuleset)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "id": str(self.id),
            "policyName": self.policy_name,
            "version": self.version,
            "priority": self.priority,
            "permissive": self.permissive,
            "description": self.description,
        }
        append_optional_value(
            data, "issuingOrganization", self.issuing_organization, to_dict_class=True
        )
        append_optional_list(data, "rulesets", self.rulesets, to_dict_class=True)

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyProps":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        id = UUID(data["id"])
        policy_name = data["policyName"]
        version = data["version"]
        priority = data["priority"]
        permissive = data["permissive"]
        description = data["description"]
        issuing_organization = parse_optional(
            data, "issuingOrganization", PolicyOrganization
        )
        rulesets = parse_optional_list(data, "rulesets", PolicyRuleset)

        return PolicyProps(
            id=id,
            policy_name=policy_name,
            version=version,
            priority=priority,
            permissive=permissive,
            description=description,
            issuing_organization=issuing_organization,
            rulesets=rulesets,
        )


@dataclass(frozen=True)
class PolicyDataMicca:
    """
    Dataclass for PolicyDataMICCA.schema.json
    """

    name: str
    props: PolicyProps

    def __post_init__(self):
        check_object_field(self, "name", str)
        check_object_field(self, "props", PolicyProps)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"name": self.name, "props": self.props.to_dict()}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PolicyDataMicca":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """

        name = data["name"]
        props = PolicyProps.from_dict(data["props"])

        return PolicyDataMicca(name=name, props=props)


@dataclass(frozen=True)
class DsaActionDescription:
    """
    Dataclass for DSAActionDescription.schema.json
    """

    dsa_json_policy_list: List[PolicyDataMicca]

    def __post_init__(self):
        check_object_list(
            self, "dsa_json_policy_list", PolicyDataMicca, allow_empty=True
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"dsaJsonPolicyList": to_dict_list(self.dsa_json_policy_list)}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DsaActionDescription":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        dsa_json_policy_list = from_dict_list(
            data["dsaJsonPolicyList"], PolicyDataMicca
        )

        return DsaActionDescription(dsa_json_policy_list=dsa_json_policy_list)


class DsaActionType(enum.IntEnum):
    """
    Defines valid enumerations for ActionType
    """

    DSA_JSON = enum.auto()

    def __str__(self):
        return self.name


class FreqActionType(enum.IntEnum):
    """
    Defines valid enumerations for ActionType
    """

    # pylint: disable=invalid-name
    frequency_list = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class RadioMetrics:
    """
    Defines the dataclass for RadioMetrics.schema.json
    """

    peer_id: int
    mcs_idx: int
    rssi: Union[float, int]
    evm: Union[float, int]
    per: Union[float, int]

    def __post_init__(self):
        check_object_field(self, "peer_id", int)
        check_object_field(self, "mcs_idx", int)
        check_object_field(self, "rssi", (float, int))
        check_object_field(self, "evm", (float, int))
        check_object_field(self, "per", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "peerId": self.peer_id,
            "mcsidx": self.mcs_idx,
            "rssi": self.rssi,
            "evm": self.evm,
            "per": self.per,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioMetrics":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        peer_id = data["peerId"]
        mcs_idx = data["mcsidx"]
        rssi = data["rssi"]
        evm = data["evm"]
        per = data["per"]

        return RadioMetrics(
            peer_id=peer_id,
            mcs_idx=mcs_idx,
            rssi=rssi,
            evm=evm,
            per=per,
        )


class GpsStatus(enum.IntEnum):
    """
    Models the RadioStatus.schema.json gpsStatus enumeration
    """

    # pylint: disable=invalid-name
    valid = enum.auto()
    no_gps_device = enum.auto()
    low_satellite_count = enum.auto()
    simulated = enum.auto()

    def __str__(self):
        return self.name.replace("_", " ")

    @classmethod
    def from_str(cls, item: str):
        return GpsStatus[item.replace(" ", "_")]


@dataclass(frozen=True)
class RadioStatus:
    """
    Defines the dataclass representing RadioStatus.schema.json
    """

    last_radio_communication: dt
    heartbeat_expected_1hr: int
    heartbeat_actual_1hr: int
    gps_status: GpsStatus
    gps_accuracy: Union[float, int]
    gps_accuracy_unit: str
    altitude: Union[float, int]
    altitude_unit: str
    latitude: Union[float, int]
    longitude: Union[float, int]
    vector_latitude_sec: Union[float, int]
    vector_longitude_sec: Union[float, int]
    vector_altitude_sec: Union[float, int]
    bandwidth_hz: Union[float, int]
    center_freq_hz: Union[float, int]
    power_dbm: Union[float, int]

    def __post_init__(self):
        check_object_field(self, "last_radio_communication", dt)
        check_object_field(self, "heartbeat_expected_1hr", int)
        check_object_field(self, "heartbeat_actual_1hr", int)
        check_object_field(self, "gps_status", GpsStatus)
        check_object_field(self, "gps_accuracy", (float, int))
        check_object_field(self, "gps_accuracy_unit", str)
        check_object_field(self, "altitude", (float, int))
        check_object_field(self, "altitude_unit", str)
        check_object_field(self, "latitude", (float, int))
        check_object_field(self, "longitude", (float, int))
        check_object_field(self, "vector_latitude_sec", (float, int))
        check_object_field(self, "vector_longitude_sec", (float, int))
        check_object_field(self, "vector_altitude_sec", (float, int))
        check_object_field(self, "bandwidth_hz", (float, int))
        check_object_field(self, "center_freq_hz", (float, int))
        check_object_field(self, "power_dbm", (float, int))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "lastRadioCommunication": get_timestamp_as_str(
                self.last_radio_communication
            ),
            "heartBeatExpected_1hr": self.heartbeat_expected_1hr,
            "heartBeatActual_1hr": self.heartbeat_actual_1hr,
            "gpsStatus": str(self.gps_status),
            "gpsAccuracy": self.gps_accuracy,
            "gpsAccuracyUnit": self.gps_accuracy_unit,
            "altitude": self.altitude,
            "altitudeUnit": self.altitude_unit,
            "latitude": self.latitude,
            "longitude": self.longitude,
            "vectorLatitudeSec": self.vector_latitude_sec,
            "vectorLongitudeSec": self.vector_longitude_sec,
            "vectorAltitudeSec": self.vector_altitude_sec,
            "bandWidth_hz": self.bandwidth_hz,
            "centerFreq_hz": self.center_freq_hz,
            "powerDbm": self.power_dbm,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioStatus":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        last_radio_communication = get_timestamp_from_str(
            data["lastRadioCommunication"]
        )
        heartbeat_expected_1hr = data["heartBeatExpected_1hr"]
        heartbeat_actual_1hr = data["heartBeatActual_1hr"]
        gps_status = GpsStatus.from_str(data["gpsStatus"])
        gps_accuracy = data["gpsAccuracy"]
        gps_accuracy_unit = data["gpsAccuracyUnit"]
        altitude = data["altitude"]
        altitude_unit = data["altitudeUnit"]
        latitude = data["latitude"]
        longitude = data["longitude"]
        vector_latitude_sec = data["vectorLatitudeSec"]
        vector_longitude_sec = data["vectorLongitudeSec"]
        vector_altitude_sec = data["vectorAltitudeSec"]
        bandwidth_hz = data["bandWidth_hz"]
        center_freq_hz = data["centerFreq_hz"]
        power_dbm = data["powerDbm"]

        return RadioStatus(
            last_radio_communication=last_radio_communication,
            heartbeat_expected_1hr=heartbeat_expected_1hr,
            heartbeat_actual_1hr=heartbeat_actual_1hr,
            gps_status=gps_status,
            gps_accuracy=gps_accuracy,
            gps_accuracy_unit=gps_accuracy_unit,
            altitude=altitude,
            altitude_unit=altitude_unit,
            latitude=latitude,
            longitude=longitude,
            vector_latitude_sec=vector_latitude_sec,
            vector_longitude_sec=vector_longitude_sec,
            vector_altitude_sec=vector_altitude_sec,
            bandwidth_hz=bandwidth_hz,
            center_freq_hz=center_freq_hz,
            power_dbm=power_dbm,
        )


@dataclass(frozen=True)
class Radio:
    """
    Defines the dataclass for Radio.schema.json
    """

    radio_serial_number: str
    radio_physical_serial_number: str
    net_id: UUID
    radio_type: str
    radio_waveform: str
    radio_status: RadioStatus
    node_id: Union[float, int]
    num_nodes: int
    metrics: Union[List[RadioMetrics], None] = None

    def __post_init__(self):
        check_object_field(self, "radio_serial_number", str)
        check_object_field(self, "radio_physical_serial_number", str)
        check_object_field(self, "net_id", UUID)
        check_object_field(self, "radio_type", str)
        check_object_field(self, "radio_waveform", str)
        check_object_field(self, "radio_status", RadioStatus)
        check_object_field(self, "node_id", (float, int))
        check_object_field(self, "num_nodes", int)
        check_optional_list(self, "metrics", RadioMetrics, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "radioSerialNumber": self.radio_serial_number,
            "radioPhysicalSerialNumber": self.radio_physical_serial_number,
            "netId": str(self.net_id),
            "radioType": self.radio_type,
            "radioWaveForm": self.radio_waveform,
            "radioStatus": self.radio_status.to_dict(),
            "nodeId": self.node_id,
            "numNodes": self.num_nodes,
        }
        append_optional_list(data, "metrics", self.metrics, to_dict_class=True)

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Radio":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        radio_serial_number = data["radioSerialNumber"]
        radio_physical_serial_number = data["radioPhysicalSerialNumber"]
        net_id = UUID(data["netId"])
        radio_type = data["radioType"]
        radio_waveform = data["radioWaveForm"]
        radio_status = RadioStatus.from_dict(data["radioStatus"])
        node_id = data["nodeId"]
        num_nodes = data["numNodes"]
        metrics = parse_optional_list(data, "metrics", RadioMetrics)

        return Radio(
            radio_serial_number=radio_serial_number,
            radio_physical_serial_number=radio_physical_serial_number,
            net_id=net_id,
            radio_type=radio_type,
            radio_waveform=radio_waveform,
            radio_status=radio_status,
            node_id=node_id,
            num_nodes=num_nodes,
            metrics=metrics,
        )


@dataclass(frozen=True)
class RadioEnvironmentDataReportMt:
    """
    Defines the dataclass for RadioEnvironmentDataReport_MT.schema.json
    """

    radios: List[Radio]
    request_message_id: Union[UUID, None] = None

    def __post_init__(self):
        check_object_list(self, "radios", Radio, allow_empty=True)
        check_optional_type(self, "request_message_id", UUID)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "radios": to_dict_list(self.radios),
        }
        append_optional_value(
            data, "requestMessageId", self.request_message_id, to_str=True
        )

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioEnvironmentDataReportMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        radios = from_dict_list(data["radios"], Radio)
        request_message_id = parse_optional(data, "requestMessageId")
        if request_message_id is not None:
            request_message_id = UUID(request_message_id)

        return RadioEnvironmentDataReportMt(
            radios=radios,
            request_message_id=request_message_id,
        )


@dataclass(frozen=True)
class RadioEnvironmentDataRequestMt:
    """
    Defines a dataclass representing RadioEnvironmentData_MT.schema.json.
    """

    detailed: bool

    def __post_init__(self):
        check_object_field(self, "detailed", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {"detailed": self.detailed}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioEnvironmentDataRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        detailed = data["detailed"]
        return RadioEnvironmentDataRequestMt(detailed=detailed)


@dataclass(frozen=True)
class RadioPlan:
    """
    Defines a dataclass representing RadioPlan.schema.json
    """

    plan_id: UUID
    plan_name: str
    plan_receive_time: dt
    plan_status_time: dt
    plan_status: PlanStatus
    net_plans: List[NetPlan]

    def __post_init__(self):
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)
        check_object_field(self, "plan_receive_time", dt)
        check_object_field(self, "plan_status_time", dt)
        check_object_field(self, "plan_status", PlanStatus)
        check_object_list(self, "net_plans", NetPlan, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "planId": str(self.plan_id),
            "planName": self.plan_name,
            "planReceiveTime": get_timestamp_as_str(self.plan_receive_time),
            "planStatusTime": get_timestamp_as_str(self.plan_status_time),
            "planStatus": str(self.plan_status),
            "netPlans": to_dict_list(self.net_plans),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioPlan":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        plan_id = UUID(data["planId"])
        plan_name = data["planName"]
        plan_receive_time = get_timestamp_from_str(data["planReceiveTime"])
        plan_status_time = get_timestamp_from_str(data["planStatusTime"])
        plan_status = PlanStatus.from_str(data["planStatus"])
        net_plans = from_dict_list(data["netPlans"], NetPlan)

        return RadioPlan(
            plan_id=plan_id,
            plan_name=plan_name,
            plan_receive_time=plan_receive_time,
            plan_status_time=plan_status_time,
            plan_status=plan_status,
            net_plans=net_plans,
        )


@dataclass(frozen=True)
class RadioPlanReportMt:
    """
    Defines a dataclass representing RadioPlanReport_MT.schema.json
    """

    request_message_id: UUID
    mission_name: str
    mission_id: UUID
    plan: RadioPlan

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_field(self, "mission_name", str)
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "plan", RadioPlan)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "missionName": self.mission_name,
            "missionId": str(self.mission_id),
            "plan": self.plan.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioPlanReportMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        mission_name = str(data["missionName"])
        mission_id = UUID(data["missionId"])
        plan = RadioPlan.from_dict(data["plan"])

        return RadioPlanReportMt(
            request_message_id=request_message_id,
            mission_name=mission_name,
            mission_id=mission_id,
            plan=plan,
        )


@dataclass(frozen=True)
class DsaRadioActions:
    """
    Defines the dataclass for DSARadioActions.schema.json
    """

    action_type: DsaActionType
    action_description: DsaActionDescription
    transmit_power: PowerQuantity
    plan_start_time: dt
    plan_end_time: dt

    def __post_init__(self):
        check_object_field(self, "action_type", DsaActionType)
        check_optional_type(self, "action_description", DsaActionDescription)
        check_object_field(self, "transmit_power", PowerQuantity)
        check_object_field(self, "plan_start_time", dt)
        check_object_field(self, "plan_end_time", dt)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "actionType": str(self.action_type),
            "actionDescription": self.action_description.to_dict(),
            "trasmitPower": self.transmit_power.to_dict(),
            "planStartTime": get_timestamp_as_str(self.plan_start_time),
            "planEndTime": get_timestamp_as_str(self.plan_end_time),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DsaRadioActions":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        action_type = parse_enum_from_dict(data, "actionType", DsaActionType)
        action_description = DsaActionDescription.from_dict(data["actionDescription"])
        transmit_power = PowerQuantity.from_dict(data["trasmitPower"])
        plan_start = get_timestamp_from_str(data["planStartTime"])
        plan_end = get_timestamp_from_str(data["planEndTime"])

        return DsaRadioActions(
            action_type=action_type,
            action_description=action_description,
            transmit_power=transmit_power,
            plan_start_time=plan_start,
            plan_end_time=plan_end,
        )


@dataclass(frozen=True)
class FreqRadioActions:
    """
    Defines the dataclass for FreqRadioActions.schema.json
    """

    action_type: FreqActionType
    action_description: FrequencyListQuantity
    transmit_power: PowerQuantity
    bandwidth: FrequencyQuantity
    plan_gps_area: GeoJsonFeature

    def __post_init__(self):
        check_object_field(self, "action_type", FreqActionType)
        check_optional_type(self, "action_description", FrequencyListQuantity)
        check_object_field(self, "transmit_power", PowerQuantity)
        check_object_field(self, "bandwidth", FrequencyQuantity)
        check_object_field(self, "plan_gps_area", GeoJsonFeature)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "actionType": str(self.action_type),
            "transmitPower": self.transmit_power.to_dict(),
            "bandWidth": self.bandwidth.to_dict(),
            "planGpsArea": self.plan_gps_area.to_dict(),
        }

        append_optional_value(
            data, "actionDescription", self.action_description, to_dict_class=True
        )

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FreqRadioActions":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        action_type = parse_enum_from_dict(data, "actionType", FreqActionType)
        action_description = parse_optional(
            data, "actionDescription", FrequencyListQuantity
        )
        transmit_power = PowerQuantity.from_dict(data["transmitPower"])
        bandwidth = FrequencyQuantity.from_dict(data["bandWidth"])
        plan_gps_area = GeoJsonFeature.from_dict(data["planGpsArea"])

        return FreqRadioActions(
            action_type=action_type,
            action_description=action_description,
            transmit_power=transmit_power,
            bandwidth=bandwidth,
            plan_gps_area=plan_gps_area,
        )


class RadioActionsType(enum.IntEnum):
    """
    Defines enumerations for RadioActions.schema.json types
    """

    # pylint: disable=invalid-name
    frequency_list = enum.auto()
    DSA_JSON = enum.auto()

    def __str__(self):
        return self.name


@dataclass(frozen=True)
class RadioActions:
    """
    Defines the dataclass representing RadioActions.schema.json
    """

    __RADIO_ACTIONS_CLASS_MAP: ClassVar[dict] = {
        RadioActionsType.frequency_list: FreqRadioActions,
        RadioActionsType.DSA_JSON: DsaRadioActions,
    }

    action: Union[FreqRadioActions, DsaRadioActions]

    def __post_init__(self):
        check_object_field(self, "action", (FreqRadioActions, DsaRadioActions))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return self.action.to_dict()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioActions":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        action_type = RadioActionsType[data["actionType"]]
        action_class = cls.__RADIO_ACTIONS_CLASS_MAP[action_type]
        action = action_class.from_dict(data)
        return RadioActions(action=action)


@dataclass(frozen=True)
class Heartbeat:
    """
    Defines the dataclass for micca Heartbeat.schema.json
    """

    cm_heartbeat_interval: TimeQuantity
    crc_heartbeat_interval: TimeQuantity
    crc_sds_interval: TimeQuantity
    cm_report_interval: Union[TimeQuantity, None] = None

    def __post_init__(self):
        check_object_field(self, "cm_heartbeat_interval", TimeQuantity)
        check_object_field(self, "crc_heartbeat_interval", TimeQuantity)
        check_object_field(self, "crc_sds_interval", TimeQuantity)
        check_optional_type(self, "cm_report_interval", TimeQuantity)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "cmHeartbeatInterval": self.cm_heartbeat_interval.to_dict(),
            "crcHeartbeatInterval": self.crc_heartbeat_interval.to_dict(),
            "crcSdsInterval": self.crc_sds_interval.to_dict(),
        }
        append_optional_value(
            data, "cmReportInterval", self.cm_report_interval, to_dict_class=True
        )

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Heartbeat":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        cm_heartbeat_interval = TimeQuantity.from_dict(data["cmHeartbeatInterval"])
        crc_heartbeat_interval = TimeQuantity.from_dict(data["crcHeartbeatInterval"])
        crc_sds_interval = TimeQuantity.from_dict(data["crcSdsInterval"])
        cm_report_interval = parse_optional(data, "cmReportInterval", TimeQuantity)

        return Heartbeat(
            cm_heartbeat_interval=cm_heartbeat_interval,
            crc_heartbeat_interval=crc_heartbeat_interval,
            cm_report_interval=cm_report_interval,
            crc_sds_interval=crc_sds_interval,
        )


@dataclass(frozen=True)
class Plan:
    """
    Defines a dataclass representing Plan.schema.json
    """

    net_id: UUID
    net_name: str
    min_radio_count: int
    suggested_radio_count: int
    radio_actions: RadioActions
    plan_start_time: dt
    plan_end_time: dt
    plan_deploy_time: dt
    plan_deploy_end_time: dt
    reports: Heartbeat

    def __post_init__(self):
        check_object_field(self, "net_id", UUID)
        check_object_field(self, "net_name", str)
        check_object_field(self, "min_radio_count", int)
        check_object_field(self, "suggested_radio_count", int)
        check_object_field(self, "radio_actions", RadioActions)
        check_object_field(self, "plan_start_time", dt)
        check_object_field(self, "plan_end_time", dt)
        check_object_field(self, "plan_deploy_time", dt)
        check_object_field(self, "plan_deploy_end_time", dt)
        check_object_field(self, "reports", Heartbeat)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "netId": str(self.net_id),
            "netName": self.net_name,
            "minRadioCount": self.min_radio_count,
            "suggestedRadioCount": self.suggested_radio_count,
            "radioActions": self.radio_actions.to_dict(),
            "planStartTime": get_timestamp_as_str(self.plan_start_time),
            "planEndTime": get_timestamp_as_str(self.plan_end_time),
            "planDeployTime": get_timestamp_as_str(self.plan_deploy_time),
            "planDeployEndTime": get_timestamp_as_str(self.plan_deploy_end_time),
            "reports": self.reports.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Plan":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        net_id = UUID(data["netId"])
        net_name = data["netName"]
        min_radio_count = data["minRadioCount"]
        suggested_radio_count = data["suggestedRadioCount"]
        radio_actions = RadioActions.from_dict(data["radioActions"])
        plan_start_time = get_timestamp_from_str(data["planStartTime"])
        plan_end_time = get_timestamp_from_str(data["planEndTime"])
        plan_deploy_time = get_timestamp_from_str(data["planDeployTime"])
        plan_deploy_end_time = get_timestamp_from_str(data["planDeployEndTime"])
        reports = Heartbeat.from_dict(data["reports"])

        return Plan(
            net_id=net_id,
            net_name=net_name,
            min_radio_count=min_radio_count,
            suggested_radio_count=suggested_radio_count,
            radio_actions=radio_actions,
            plan_start_time=plan_start_time,
            plan_end_time=plan_end_time,
            plan_deploy_time=plan_deploy_time,
            plan_deploy_end_time=plan_deploy_end_time,
            reports=reports,
        )


@dataclass(frozen=True)
class RadioPlanRequestMt:
    """
    Defines a dataclass representing RadioPlanRequest_MT.schema.json
    """

    mission_id: UUID
    mission_name: str
    mission_gps_area: GeoJsonFeature
    plan_id: UUID
    plan_name: str
    net_plans: List[Plan]

    def __post_init__(self):
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "mission_name", str)
        check_object_field(self, "mission_gps_area", GeoJsonFeature)
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)
        check_object_list(self, "net_plans", Plan, allow_empty=True)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "missionId": str(self.mission_id),
            "missionName": self.mission_name,
            "missionGpsArea": self.mission_gps_area.to_dict(),
            "planId": str(self.plan_id),
            "planName": self.plan_name,
            "netPlans": to_dict_list(self.net_plans),
        }

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioPlanRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        mission_id = UUID(data["missionId"])
        mission_name = str(data["missionName"])
        mission_gps_area = GeoJsonFeature.from_dict(data["missionGpsArea"])
        plan_id = UUID(data["planId"])
        plan_name = str(data["planName"])
        net_plans = from_dict_list(data["netPlans"], Plan)

        return RadioPlanRequestMt(
            mission_id=mission_id,
            mission_name=mission_name,
            mission_gps_area=mission_gps_area,
            plan_id=plan_id,
            plan_name=plan_name,
            net_plans=net_plans,
        )


@dataclass(frozen=True)
class RadioPlanStatusReportMt:
    """
    Defines a dataclass representing RadioPlanStatusReport_MT.schema.json
    """

    request_message_id: UUID
    mission_name: str
    mission_id: UUID
    plan: RadioPlan

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_field(self, "mission_name", str)
        check_object_field(self, "mission_id", UUID)
        check_object_field(self, "plan", RadioPlan)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "missionName": self.mission_name,
            "missionId": str(self.mission_id),
            "plan": self.plan.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioPlanStatusReportMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        mission_name = str(data["missionName"])
        mission_id = UUID(data["missionId"])
        plan = RadioPlan.from_dict(data["plan"])

        return RadioPlanStatusReportMt(
            request_message_id=request_message_id,
            mission_name=mission_name,
            mission_id=mission_id,
            plan=plan,
        )


@dataclass(frozen=True)
class RadioPlanStatusRequestMt:
    """
    Defines a dataclass representing RadioPlanStatusRequest_MT.schema.json
    """

    plan_id: UUID
    plan_name: str

    def __post_init__(self):
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "planId": str(self.plan_id),
            "planName": self.plan_name,
        }

        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadioPlanStatusRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        plan_id = UUID(data["planId"])
        plan_name = data["planName"]

        return RadioPlanStatusRequestMt(
            plan_id=plan_id,
            plan_name=plan_name,
        )


@dataclass(frozen=True)
class RemovePlanReportMt:
    """
    Defines a dataclass representing RemovePlanReport_MT.schema.json
    """

    request_message_id: UUID
    plan_id: UUID
    plan_name: str
    plan_removed: bool

    def __post_init__(self):
        check_object_field(self, "request_message_id", UUID)
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)
        check_object_field(self, "plan_removed", bool)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "requestMessageId": str(self.request_message_id),
            "planId": str(self.plan_id),
            "planName": self.plan_name,
            "planRemoved": self.plan_removed,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RemovePlanReportMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        request_message_id = UUID(data["requestMessageId"])
        plan_id = UUID(data["planId"])
        plan_name = str(data["planName"])
        plan_removed = data["planRemoved"]

        return RemovePlanReportMt(
            request_message_id=request_message_id,
            plan_id=plan_id,
            plan_name=plan_name,
            plan_removed=plan_removed,
        )


@dataclass(frozen=True)
class RemovePlanRequestMt:
    """
    Defines a dataclass representing RemovePlanRequest_MT.schema.json
    """

    plan_id: UUID
    plan_name: str

    def __post_init__(self):
        check_object_field(self, "plan_id", UUID)
        check_object_field(self, "plan_name", str)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "planId": str(self.plan_id),
            "planName": self.plan_name,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RemovePlanRequestMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        plan_id = UUID(data["planId"])
        plan_name = data["planName"]

        return RemovePlanRequestMt(
            plan_id=plan_id,
            plan_name=plan_name,
        )


@dataclass(frozen=True)
class Message:
    """
    Defines a dataclass representing Message.schema.json.
    """

    __MESSAGE_TYPE_MAP: ClassVar[dict] = {
        MessageType.Ack: AckMt,
        MessageType.Heartbeat: HeartbeatMt,
        MessageType.HistoricalSpectrumDataRequest: HistoricalSpectrumDataRequestMt,
        MessageType.HistoricalSpectrumDataResponse: HistoricalSpectrumDataResponseMt,
        MessageType.LiveSpectrumDataRequest: LiveSpectrumDataRequestMt,
        MessageType.LiveSpectrumDataResponse: LiveSpectrumDataResponseMt,
        MessageType.MissionPlanDescriptor: MissionPlanDescriptorMt,
        MessageType.MissionPlanDescriptorRequest: MissionPlanDescriptorRequestMt,
        MessageType.Nack: NackMt,
        MessageType.PolicyAssessmentRequest: PolicyAssessmentRequestMt,
        MessageType.PolicyAssessmentResponse: PolicyAssessmentResponseMt,
        MessageType.PolicyGenerationRequest: PolicyGenerationRequestMt,
        MessageType.PolicyOptimizationRequest: PolicyOptimizationRequestMt,
        MessageType.RiskInformedPolicyResponse: RiskInformedPolicyResponseMt,
        MessageType.SensorConfiguration: SensorConfigurationMt,
        MessageType.SensorNetworkDescriptor: SensorNetworkDescriptorMt,
        MessageType.SensorNetworkDescriptorRequest: SensorNetworkDescriptorRequestMt,
        MessageType.SpectrumData: SpectrumDataMt,
        MessageType.ActivePlansReport: ActivePlansReportMt,
        MessageType.ActivePlansRequest: ActivePlansRequestMt,
        MessageType.HeartbeatReport: HeartbeatReportMt,
        MessageType.HeartbeatRequest: HeartbeatRequestMt,
        MessageType.RadioEnvironmentDataReport: RadioEnvironmentDataReportMt,
        MessageType.RadioEnvironmentDataRequest: RadioEnvironmentDataRequestMt,
        MessageType.RadioPlanReport: RadioPlanReportMt,
        MessageType.RadioPlanRequest: RadioPlanRequestMt,
        MessageType.RadioPlanStatusReport: RadioPlanStatusReportMt,
        MessageType.RadioPlanStatusRequest: RadioPlanStatusRequestMt,
        MessageType.RemovePlanReport: RemovePlanReportMt,
        MessageType.RemovePlanRequest: RemovePlanRequestMt,
    }

    type: MessageType
    body: Union[
        AckMt,
        HeartbeatMt,
        HistoricalSpectrumDataRequestMt,
        HistoricalSpectrumDataResponseMt,
        LiveSpectrumDataRequestMt,
        LiveSpectrumDataResponseMt,
        MissionPlanDescriptorMt,
        MissionPlanDescriptorRequestMt,
        NackMt,
        PolicyAssessmentRequestMt,
        PolicyAssessmentResponseMt,
        PolicyGenerationRequestMt,
        PolicyOptimizationRequestMt,
        RiskInformedPolicyResponseMt,
        SensorConfigurationMt,
        SensorNetworkDescriptorMt,
        SensorNetworkDescriptorRequestMt,
        SpectrumDataMt,
        ActivePlansReportMt,
        ActivePlansRequestMt,
        HeartbeatReportMt,
        HeartbeatRequestMt,
        RadioEnvironmentDataReportMt,
        RadioEnvironmentDataRequestMt,
        RadioPlanReportMt,
        RadioPlanRequestMt,
        RadioPlanStatusReportMt,
        RadioPlanStatusRequestMt,
        RemovePlanReportMt,
        RemovePlanRequestMt,
    ]

    def __post_init__(self):
        check_object_field(self, "type", allowed_types=MessageType)
        check_object_field(
            self,
            "body",
            allowed_types=(
                AckMt,
                HeartbeatMt,
                HistoricalSpectrumDataRequestMt,
                HistoricalSpectrumDataResponseMt,
                LiveSpectrumDataRequestMt,
                LiveSpectrumDataResponseMt,
                MissionPlanDescriptorMt,
                MissionPlanDescriptorRequestMt,
                NackMt,
                PolicyAssessmentRequestMt,
                PolicyAssessmentResponseMt,
                PolicyGenerationRequestMt,
                PolicyOptimizationRequestMt,
                RiskInformedPolicyResponseMt,
                SensorConfigurationMt,
                SensorNetworkDescriptorMt,
                SensorNetworkDescriptorRequestMt,
                SpectrumDataMt,
                ActivePlansReportMt,
                ActivePlansRequestMt,
                HeartbeatReportMt,
                HeartbeatRequestMt,
                RadioEnvironmentDataReportMt,
                RadioEnvironmentDataRequestMt,
                RadioPlanReportMt,
                RadioPlanRequestMt,
                RadioPlanStatusReportMt,
                RadioPlanStatusRequestMt,
                RemovePlanReportMt,
                RemovePlanRequestMt,
            ),
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        return {
            "type": str(self.type),
            "body": self.body.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Message":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        body_type = MessageType[data["type"]]
        body_class = cls.__MESSAGE_TYPE_MAP[body_type]
        body = body_class.from_dict(data["body"])
        return Message(
            type=body_type,
            body=body,
        )

    @classmethod
    def create_ack(cls, request_message_id: Union[UUID, str]) -> "Message":
        """
        Create Message containing AckMt for the given request message id.
        """
        if isinstance(request_message_id, str):
            request_message_id = UUID(request_message_id)
        return Message(
            type=MessageType.Ack, body=AckMt(request_message_id=request_message_id)
        )

    @classmethod
    def create_heartbeat_from_status(cls, status: Status) -> "Message":
        """
        Create Message containing HeartbeatMt for the given
        :py:class:`~risa.messages.Status` message.
        """
        instance_id = UUID(uuid5.get_tranche2_uuid5("risa-origin", status.name))
        timeout = dt.now() + timedelta(seconds=status.reporting_interval)
        return Message(
            type=MessageType.Heartbeat,
            body=HeartbeatMt(instance_id=instance_id, timeout=timeout),
        )


@dataclass(frozen=True)
class MessageEnvelopeMt:
    """
    Defines a dataclass representing MessageEnvelope_MT.schema.json.
    """

    version: versioning.SemanticVersion
    timestamp: dt
    message_id: UUID
    message: Message

    def __post_init__(self):
        check_object_field(self, "version", allowed_types=versioning.SemanticVersion)
        check_object_field(self, "timestamp", allowed_types=dt)
        check_object_field(self, "message_id", allowed_types=UUID)
        check_object_field(self, "message", allowed_types=Message)

    def to_dict(self) -> Dict[str, Any]:
        """
        Return Tranche2 compatible JSON.
        """
        data = {
            "version": str(self.version),
            "timestamp": get_timestamp_as_str(self.timestamp),
            "messageId": str(self.message_id),
            "message": self.message.to_dict(),
        }
        checksum.append(data)
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MessageEnvelopeMt":
        """
        Convert Tranche2 compatible JSON.

        Parameters
        ----------
        data : Dict[str, Any]
            The dictionary of data to convert

        Raises
        ------
        KeyError
            If a value is missing
        """
        # TODO: validate checksum?
        version = versioning.get_semantic_version(data["version"])
        timestamp = get_timestamp_from_str(data["timestamp"])
        message_id = UUID(data["messageId"])
        message = Message.from_dict(data["message"])
        return MessageEnvelopeMt(
            version=version,
            timestamp=timestamp,
            message_id=message_id,
            message=message,
        )

    @classmethod
    def from_callback_data(
        cls, callback_data: RabbitMqBasicConsumeCallbackData
    ) -> "MessageEnvelopeMt":
        """
        Convert data received from RMQ into a MessageEnvelopeMt

        Parameters
        ----------
        callback_data : :py:class:`RabbitMqBasicConsumeCallbackData`
            The data to convert into a MessageEnvelopeMt

        Returns
        -------
        MessageEnvelopeMt
        """
        return cls.from_dict(callback_data.json_data)

    @classmethod
    def from_message(
        cls,
        message: Message,
        version: Union[versioning.SemanticVersion, None] = None,
        timestamp: Union[dt, None] = None,
        message_id: Union[UUID, str, None] = None,
    ) -> "MessageEnvelopeMt":
        """
        Create a message envelope for a given message

        Parameters
        ----------
        message : :py:class:`Message`
            The message to create an envelope for.

        version : Union[versioning.SemanticVersion, None], default=None
            The version to use for the message envelope.

            If None, uses the module SCHEMA_VERSION

        timestamp : Union[datetime, None], default=None
            The timestamp for the message envelope.

            If None, uses the current datetime.

        message_id : Union[UUID, str, None], default=None
            The message id for the message envelope.

            If None, a message ID will be generated.

        Returns
        -------
        MessageEnvelopeMt
        """
        if version is None:
            version = SCHEMA_VERSION
        if timestamp is None:
            timestamp = dt.now()
        if message_id is None:
            message_id = UUID(
                uuid5.get_tranche2_uuid5(
                    "risa-origin",
                    "for_message" + str(message.type) + get_timestamp_as_str(timestamp),
                )
            )
        else:
            if isinstance(message_id, str):
                message_id = UUID(message_id)
        return MessageEnvelopeMt(
            version=version, timestamp=timestamp, message_id=message_id, message=message
        )



#these are from arip/geo.py
"""
Defines helper classes for handling geo related data.
"""

# Leidos Copyright 2023
#
# DISTRIBUTION D: Distribution authorized to Department of Defense and U.S. DoD
# contractors only; Proprietary Information; Export Controlled; Oct 2021. Other
# requests for this document shall be referred to Naval Research Laboratory, 4555
# Overlook Avenue SW, Washington, DC 20375-5320.

import logging
import os
import re
from itertools import chain
from typing import Any, Callable, List, Tuple

# requires pyproj >= 2.2.0
import pyproj
from pyproj.aoi import AreaOfInterest
from pyproj.enums import TransformDirection

from shapely import Point, Polygon, LinearRing
from shapely.ops import transform

import numpy as np

from risa.tranche2.messages import (
    GeoJsonFeature,
    GeoJsonPoint,
    GeoJsonPolygon,
    GeoSpatialInfo,
    GeoSpatialInfoCircle,
    GeoSpatialInfoPolygon,
    GeoSpatialInfoShape,
)

logger = logging.getLogger("arip.geo")


def find_epsgs(
    west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree, contains=False
):
    """
    Look up European Petroleum Survey Group (EPSG) Geodetic Parameter Dataset
    based on a given area of interest, specified in lat/lon.

    Parameters
    ----------
    west_lon_degree : float
        Western longitude for area of interest

    south_lat_degree : float
        Southern latitude for area of interest

    east_lon_degree : float
        Eastern longitude for area of interest

    north_lat_degree : float
        Northern latitude for area of interest

    contains : bool, default=False
        Return only EPSG which contain the area of interest

    Returns
    -------
    crs_info : List[``pyproj.database.CRSInfo`]
        Information about the EPSG

        Codes can be accessed via `crs_info[x].code`
    """
    crs_info = pyproj.database.query_crs_info(
        auth_name="EPSG",
        area_of_interest=AreaOfInterest(
            west_lon_degree=west_lon_degree,
            south_lat_degree=south_lat_degree,
            east_lon_degree=east_lon_degree,
            north_lat_degree=north_lat_degree,
        ),
        contains=contains,
    )
    return crs_info


def __initialize():
    """
    Creates a ReferenceLatLonTransformer object using environment variables.

    Returns
    -------
    ReferenceLatLonTransformer
    """

    class ReferenceLatLonTransformer:
        """
        Class that provides methods for converting Lat/Lon/Alt to X/Y/Z.

        .. note::

           The current implementation doesn't convert Alt and Z

        The purpose of this class is to assist with converting data from a
        reference geodetic system (e.g., WGS84) into a local coordinate system.

        The local coordinate system units depend on the target EPSG.  In most
        cases, it will be in meters.
        """

        def __init__(
            self,
            target_crs_epsg,
            west_lon_degree,
            south_lat_degree,
            east_lon_degree,
            north_lat_degree,
            reference_height=0,
            latlon_reference_crs_epsg=4326,
        ):
            """
            target_crs_epsg : int, str
                The EPSG code to use for translating into the local coordinate
                system

            west_lon_degree : float
                Western longitude for area of interest.  Determines the "left"
                portion of the bounding box.

            south_lat_degree : float
                Southern latitude for area of interest.  Determines the "bottom"
                portion of the bounding box.

            east_lon_degree : float
                Eastern longitude for area of interest  Determines the "right"
                portion of the bounding box.

            north_lat_degree : float
                Northern latitude for area of interest  Determines the "top"
                portion of the bounding box.

            reference_height : float, default=0
                units depend on the reference EPSG

            latlon_reference_crs_epsg : int, str, default=4326
                The EPSG code to use for representing the World Geodetic System.
                The default code is for WGS84.
            """
            self.west_lon_degree = west_lon_degree
            self.south_lat_degree = south_lat_degree
            self.east_lon_degree = east_lon_degree
            self.north_lat_degree = north_lat_degree
            self.reference_height = reference_height

            # bbox
            self.latlon_bbox = [
                (west_lon_degree, south_lat_degree, reference_height),
                (west_lon_degree, north_lat_degree, reference_height),
                (east_lon_degree, south_lat_degree, reference_height),
                (east_lon_degree, north_lat_degree, reference_height),
            ]

            # this doesn't seem to help preserve units for height...
            self.lat_lon_crs = pyproj.CRS.from_epsg(latlon_reference_crs_epsg)
            self.target_crs = pyproj.CRS.from_epsg(target_crs_epsg)
            self.transformer_to_target = pyproj.Transformer.from_crs(
                self.lat_lon_crs, self.target_crs
            )

            # self.reverse_transformer = pyproj.Transformer.from_crs(
            #    self.target_crs, self.lat_lon_crs
            # )

            # this doesn't seem to help preserve units for height...
            # self.lat_lon_proj = pyproj.Proj(f'epsg:{latlon_reference_crs_epsg}')
            # self.target_proj = pyproj.Proj(f'epsg:{target_crs_epsg}', preserve_units=True)
            # self.transformer_to_target = pyproj.Transformer.from_proj(
            #     self.lat_lon_proj,
            #     self.target_proj,
            # )

            # determine 0,0 as midpoint of bounding box
            # pylint: disable=unpacking-non-sequence
            (unadjusted_min_x, unadjusted_min_y, unadjusted_z) = self.to_unadjusted_xyz(
                self.south_lat_degree, self.west_lon_degree, self.reference_height
            )
            (unadjusted_max_x, unadjusted_max_y, _) = self.to_unadjusted_xyz(
                self.north_lat_degree, self.east_lon_degree, self.reference_height
            )

            self.unadjusted_xyz_bbox = [
                (unadjusted_min_x, unadjusted_min_y, unadjusted_z),
                (unadjusted_min_x, unadjusted_max_y, unadjusted_z),
                (unadjusted_max_x, unadjusted_max_y, unadjusted_z),
                (unadjusted_max_x, unadjusted_min_y, unadjusted_z),
            ]

            self.bbox_ref_x = (unadjusted_min_x + unadjusted_max_x) / 2
            self.bbox_ref_y = (unadjusted_min_y + unadjusted_max_y) / 2

            # determine reference bbox AFTER determining midpoint
            (min_x, min_y, ref_z) = self.to_xyz(
                self.south_lat_degree, self.west_lon_degree, self.reference_height
            )
            (max_x, max_y, _) = self.to_xyz(
                self.north_lat_degree, self.east_lon_degree, self.reference_height
            )

            self.ref_z = ref_z

            # adjusted bbox
            self.xyz_bbox = [
                (min_x, min_y, ref_z),
                (min_x, max_y, ref_z),
                (max_x, max_y, ref_z),
                (max_x, min_y, ref_z),
            ]

        def get_xyz_bbox_polygon(self) -> List[List[List[Tuple[float, float, float]]]]:
            """
            Returns x, y, z local coordinates for the bounding box represented
            as a closed polygon.

            The format is similar to GeoJSON polygons.

            Returns
            -------
            List[List[List[Tuple[x, y, z]]]]
            """
            polygon = [
                [[x, y, z] for (x, y, z) in self.xyz_bbox],
                list(self.xyz_bbox[0]),
            ]
            # close loop the polygon
            return polygon

        def to_unadjusted_xyz(self, lat, lon, alt) -> Tuple[float, float, float]:
            """
            Convert lat, lon, alt coordinates into local x, y, z coordinates, where x
            corresponds to "left-right", y corresponds to "up-down", and z
            corresponds to "height-depth".

            The x, y coordinates are not shifted by the midpoint of the bounding
            box (i.e., unadjusted).

            Parameters
            ----------
            lat : float
                Latitude

            lon : float
                Longitude

            alt : float
                Altitude

            Returns
            -------
            Tuple(x, y, z)
            """
            return self.transformer_to_target.transform(lat, lon, alt)

        def to_unadjusted_xy(self, lat, lon) -> Tuple[float, float]:
            """
            Convert lat, lon coordinates into local x, y coordinates, where x
            corresponds to "left-right", and y corresponds to "up-down"

            The x, y coordinates are not shifted by the midpoint of the bounding
            box (i.e., unadjusted).

            Parameters
            ----------
            lat : float
                Latitude

            lon : float
                Longitude

            Returns
            -------
            Tuple(x, y)
            """
            return self.transformer_to_target.transform(lat, lon)

        def to_xyz(self, lat, lon, alt) -> Tuple[float, float, float]:
            """
            Convert lat, lon, alt coordinates into local x, y, z coordinates, where x
            corresponds to "left-right", y corresponds to "up-down", and z
            corresponds to "height-depth".

            The x, y coordinates are shifted by the midpoint of the bounding
            box.

            Parameters
            ----------
            lat : float
                Latitude

            lon : float
                Longitude

            alt : float
                Altitude

            Returns
            -------
            Tuple(x, y, z)
            """
            # pylint: disable=unpacking-non-sequence
            raw_x, raw_y, raw_z = self.to_unadjusted_xyz(lat, lon, alt)
            # shift relative to the bbox midpoint
            adjusted_x = raw_x - self.bbox_ref_x
            adjusted_y = raw_y - self.bbox_ref_y
            return adjusted_x, adjusted_y, raw_z

        def to_xy(self, lat: float, lon: float) -> Tuple[float, float]:
            """
            Convert lat, lon coordinates into local x, y coordinates, where x
            corresponds to "left-right" and y corresponds to "up-down".

            The x, y coordinates are shifted by the midpoint of the bounding
            box.

            Parameters
            ----------
            lat : float
                Latitude

            lon : float
                Longitude

            Returns
            -------
            Tuple(x, y)
            """
            if not isinstance(lat, (int, float)):
                raise TypeError()
            (x, y, _) = self.to_xyz(lat, lon, self.reference_height)
            return x, y

        def to_latlon_unadjusted_xyz(
            self, x: float, y: float, z: float
        ) -> Tuple[float, float, float]:
            """
            Convert local coordinates x, y, z into lat, lon, alt.

            The x, y coordinates are _not_ shifted by the midpoint of the bounding
            box (i.e., unadjusted).

            Parameters
            ----------
            x : float
                Local x coordinate

            y : float
                Local y coordinate

            z : float
                Local z coordinate (height)

            Returns
            -------
            Tuple(latitude, longitude, altitude)
            """
            # return self.reverse_transformer.transform(x, y, z)
            return self.transformer_to_target.transform(
                x, y, z, direction=TransformDirection.INVERSE
            )

        def to_latlon_unadjusted_xy(self, x: float, y: float) -> Tuple[float, float]:
            """
            Convert local coordinates x, y into lat, lon.

            The x, y coordinates are _not_ shifted by the midpoint of the bounding
            box (i.e., unadjusted).

            Parameters
            ----------
            x : float
                Local x coordinate

            y : float
                Local y coordinate

            Returns
            -------
            Tuple(latitude, longitude)
            """
            # return self.reverse_transformer.transform(x, y)
            return self.transformer_to_target.transform(
                x, y, direction=pyproj.enums.TransformDirection.INVERSE
            )

        def to_latlonalt(
            self, x: float, y: float, z: float
        ) -> Tuple[float, float, float]:
            """
            Convert local coordinates x, y, z into lat, lon, alt.

            The x, y coordinates are shifted by the midpoint of the bounding box.

            Parameters
            ----------
            x : float
                Local x coordinate

            y : float
                Local y coordinate

            z : float
                Local z coordinate (height)

            Returns
            -------
            Tuple(latitude, longitude, altitude)
            """
            # shift relative to the bbox midpoint
            adjusted_x = x + self.bbox_ref_x
            adjusted_y = y + self.bbox_ref_y
            return self.to_latlon_unadjusted_xyz(adjusted_x, adjusted_y, z)

        def to_latlon(self, x: float, y: float) -> Tuple[float, float]:
            """
            Convert local coordinates x, y into lat, lon.

            The x, y coordinates are shifted by the midpoint of the bounding box.

            Parameters
            ----------
            x : float
                Local x coordinate

            y : float
                Local y coordinate

            Returns
            -------
            Tuple(latitude, longitude)
            """
            # pylint: disable=unpacking-non-sequence
            (lat, lon, _) = self.to_latlonalt(x, y, self.ref_z)
            return lat, lon

    def __check_env_value_is_not_none(
        variable_name: str, conversion: Callable, default: Any = None
    ):
        value = os.environ.get(variable_name, default=default)
        if value is None:
            raise ValueError(f"Must specify a value for {variable_name}")
        return conversion(value)

    target_crs_epsg = __check_env_value_is_not_none(
        "ARIP_GEO_TARGET_CRS_EPSG", conversion=int, default=26946
    )
    west_lon_degree = __check_env_value_is_not_none(
        "ARIP_GEO_WEST_LON_DEGREE", conversion=float, default=-118.025483
    )
    south_lat_degree = __check_env_value_is_not_none(
        "ARIP_GEO_SOUTH_LAT_DEGREE", conversion=float, default=34.79977779041047
    )
    east_lon_degree = __check_env_value_is_not_none(
        "ARIP_GEO_EAST_LON_DEGREE", conversion=float, default=-115.7980128708217
    )
    north_lat_degree = __check_env_value_is_not_none(
        "ARIP_GEO_NORTH_LAT_DEGREE", conversion=float, default=35.64494360486573
    )
    reference_height = __check_env_value_is_not_none(
        "ARIP_GEO_REFERENCE_HEIGHT", conversion=float, default=0
    )
    latlon_reference_crs_epsg = __check_env_value_is_not_none(
        "ARIP_GEO_LATLON_REFERENCE_CRS_EPSG", conversion=int, default=4326
    )

    return ReferenceLatLonTransformer(
        target_crs_epsg=target_crs_epsg,
        west_lon_degree=west_lon_degree,
        south_lat_degree=south_lat_degree,
        east_lon_degree=east_lon_degree,
        north_lat_degree=north_lat_degree,
        reference_height=reference_height,
        latlon_reference_crs_epsg=latlon_reference_crs_epsg,
    )


Transformer = __initialize()


def _inplace_to_geojson(array: np.ndarray):
    """
    Swap coordinates for first two position (e.g., Lat/Lon -> Lon/Lat)
    """
    array[:, [1, 0]] = array[:, [0, 1]]


def convert_geo_spatial_circle_to_polygon(
    circle: GeoSpatialInfoCircle, vertices=64
) -> GeoSpatialInfoPolygon:
    """
    Converts a given circle into a polygon using the module's Transformer.

    Assumes the circle is in Lat/Lon space.

    Parameters
    ----------
    circle : risa.tranche2.messages.GeoSpatialInfoCircle
        The circle to convert into a polygon

    vertices : int, default=64
        The number of vertices to use for the circle.  The returned number
        of vertices will be this number +1 to form a closed ring.

        .. note:

           This number must be > 0 and divisible by 4.

    Returns
    -------
    risa.tranche2.messages.GeoSpatialInfoPolygon
        A closed ring in Lat/Lon space approximating the original circle.
        The number of vertices will be +1 the input value to form the closed
        ring.

    Raises
    ------
    ValueError
        If vertices is <= 0 or is not divisible by 4
    """
    if vertices <= 0:
        raise ValueError("vertices must be > 0")
    if vertices % 4 != 0:
        raise ValueError("vertices must be divisible by 4")
    quad_segs = int(vertices / 4)
    point = circle.feature.geometry.coordinates
    x, y = Transformer.to_xy(lat=point[1], lon=point[0])
    # TODO: units depend on the Transformer EPSG -- this should be something in the object interface
    #  We may even want to consider restricting EPSGs that use different units
    #  for axes...  otherwise, we may have to manage the conversions
    radius = circle.radius.m
    polygon = Point(x, y).buffer(radius, quad_segs=quad_segs)
    lat_lon_polygon = transform(Transformer.to_latlon, polygon)
    coordinates = np.array(lat_lon_polygon.exterior.coords)
    # swap lat/lon for geojson format
    _inplace_to_geojson(coordinates)
    return GeoSpatialInfoPolygon(
        feature=GeoJsonFeature(
            geometry=GeoJsonPolygon(coordinates=[coordinates]),
            properties=circle.feature.properties,
        ),
        altitude=circle.altitude,
    )


def transform_geospatial_polygon_to_xy(
    polygon: GeoSpatialInfoPolygon,
) -> GeoSpatialInfoPolygon:
    """
    Convert polygon to XY space
    """
    # TODO: support 3D...

    # polygon coordinates are specified as lon/lat,
    # but need to be lat/lon when passing to Transformer.to_xy

    remapped_coordinates = []
    for lon_lat_coords in polygon.feature.geometry.coordinates:
        # swap first to dimensions
        lat_lon_coords = lon_lat_coords[:, [1, 0]]
        remapped_coordinates.append(lat_lon_coords)

    points = list(chain(*remapped_coordinates))
    shapely_polygon = Polygon(points)
    xy_polygon = transform(Transformer.to_xy, shapely_polygon)
    exterior_coordinates = np.array(xy_polygon.exterior.coords)

    coordinates = [exterior_coordinates]
    for interior in xy_polygon.interiors:
        interior_coordinates = np.array(interior.coords)
        coordinates.append(interior_coordinates)

    return GeoSpatialInfoPolygon(
        feature=GeoJsonFeature(
            geometry=GeoJsonPolygon(coordinates=coordinates),
            properties=polygon.feature.properties,
        ),
        altitude=polygon.altitude,
    )


def transform_geospatial_polygon_to_latlon(
    polygon: GeoSpatialInfoPolygon,
) -> GeoSpatialInfoPolygon:
    """
    Convert polygon to Lat/Lon space
    """
    # TODO: support 3D...

    # polygon coordinates are specified as x/y,
    shapely_polygon = _get_shapely_polygon(polygon=polygon.feature.geometry)
    latlon_polygon = transform(Transformer.to_latlon, shapely_polygon)
    exterior_polygon = latlon_polygon.exterior
    # make sure to return a polygon that is counter-clockwise (aka, right handed)
    if exterior_polygon.is_ccw:
        ccw_polygon = exterior_polygon
    else:
        ccw_polygon = LinearRing(list(exterior_polygon.coords)[::-1])

    exterior_coordinates = np.array(ccw_polygon.coords)
    # coordinates need to be swapped to lon/lat for GeoJSON
    _inplace_to_geojson(exterior_coordinates)

    coordinates = [exterior_coordinates]

    interiors = latlon_polygon.interiors
    for interior in interiors:
        # interior rings must be clockwise
        if interior.is_ccw:
            cw_polygon = LinearRing(list(interior.coords)[::-1])
        else:
            cw_polygon = interior
        interior_coordinates = np.array(cw_polygon.coords)
        _inplace_to_geojson(interior_coordinates)
        coordinates.append(interior_coordinates)

    return GeoSpatialInfoPolygon(
        feature=GeoJsonFeature(
            geometry=GeoJsonPolygon(coordinates=coordinates),
            properties=polygon.feature.properties,
        ),
        altitude=polygon.altitude,
    )


def transform_geospatial_info_to_xy(
    geospatial_info: GeoSpatialInfo, vertices=64
) -> GeoSpatialInfo:
    """
    Convert geospatial from lat/lon to x/y.  If the geospatial info is a circle, it will be
    converted into a polygon.

    Parameters
    ----------
    geospatial_info : risa.tranche2.messages.GeoSpatialInfo
        Lat/lon data to convert

    vertices : int, default=64
        The number of vertices to use for converting a circle to a polygon
        (only applies if geospatial_info.shape is a GeoSpatialInfoCircle).
        The returned number of vertices will be this number +1 to form a
        closed ring.

        .. note:

           This number must be > 0 and divisible by 4.

    Returns
    -------
    risa.tranche2.messages.GeoSpatialInfo
        Polygon with coordinates are in x/y space
    """
    if geospatial_info.shape_type == GeoSpatialInfoShape.circle:
        polygon = convert_geo_spatial_circle_to_polygon(
            geospatial_info.shape, vertices=vertices
        )
    else:
        polygon = geospatial_info.shape

    return GeoSpatialInfo(shape=transform_geospatial_polygon_to_xy(polygon))


def transform_geospatial_info_to_lla(geospatial_info: GeoSpatialInfo) -> GeoSpatialInfo:
    """
    Convert geospatial from x/y to lat/lon.

    Parameters
    ----------
    geospatial_info : risa.tranche2.messages.GeoSpatialInfo
        Lat/lon data to convert

    Returns
    -------
    risa.tranche2.messages.GeoSpatialInfo
        Coordinates are in lat/lon space
    """
    if geospatial_info.shape_type == GeoSpatialInfoShape.circle:
        # map the x/y point to lat/lon
        coordinates = geospatial_info.shape.feature.geometry.coordinates
        x = coordinates[0]
        y = coordinates[1]
        lat, lon = Transformer.to_latlon(x=x, y=y)

        # store as lon, lat for GeoJSON
        result = GeoSpatialInfo(
            shape=GeoSpatialInfoCircle(
                feature=GeoJsonFeature(
                    geometry=GeoJsonPoint(coordinates=np.array([lon, lat])),
                    properties=geospatial_info.shape.feature.properties,
                ),
                altitude=geospatial_info.shape.altitude,
                radius=geospatial_info.shape.radius,
            )
        )
    else:
        polygon_latlon = transform_geospatial_polygon_to_latlon(
            polygon=geospatial_info.shape
        )
        result = GeoSpatialInfo(shape=polygon_latlon)

    return result


def _get_shapely_polygon(polygon: GeoJsonPolygon) -> Polygon:
    """
    Convert a GeoJsonPolygon representation into a shapely.Polygon

    Parameters
    ----------
    polygon : risa.tranche2.messages.GeoJsonPolygon
        The polygon to convert

    Returns
    -------
    shapely.Polygon
        Converted polygon
    """
    polygon_points = list(chain(*polygon.coordinates))
    return Polygon(polygon_points)


def generate_random_points_in_polygon(
    polygon: GeoSpatialInfoPolygon, n_points: int
) -> List[GeoJsonPoint]:
    """
    Generate random (x, y) points in the polygon.  The polygon should already be in xy space.

    Parameters
    ----------
    polygon : risa.tranche2.messages.GeoSpatialInfoPolygon
        The polygon to generate random points in

    n_points : int
        The number of points to generate

    Returns
    -------
    List[risa.tranche2.messages.GeoJsonPoint]
        x: coordinates[0]
        y: coordinates[1]
    """
    shapely_polygon = _get_shapely_polygon(polygon.feature.geometry)
    min_x, min_y, max_x, max_y = shapely_polygon.bounds
    # TODO: should we stop after some interval?
    logger.debug("Generating %d random points", n_points)
    points: List[GeoJsonPoint] = []
    while len(points) < n_points:
        sample = Point(np.random.uniform(min_x, max_x), np.random.uniform(min_y, max_y))
        if shapely_polygon.contains(sample):
            points.append(GeoJsonPoint(coordinates=np.array([sample.x, sample.y])))
    return points


def get_polygon_centroid(polygon: GeoJsonPolygon) -> GeoJsonPoint:
    """
    Return the centroid of a given polygon

    Parameters
    ----------
    polygon : risa.tranche2.messages.GeoJsonPolygon
        The polygon to use to determine the centroid

    Returns
    -------
    risa.tranche2.messages.GeoJsonPoint
        Centroid of the polygon
    """
    shapely_polygon = _get_shapely_polygon(polygon)
    centroid = shapely_polygon.centroid
    return GeoJsonPoint(coordinates=np.array([centroid.x, centroid.y]))


LATITUDE_DMS_PATTERN = r"(\d{2})(\d{2})(\d{2})([NS])"
LONGITUDE_DMS_PATTERN = r"(\d{3})(\d{2})(\d{2})([EW])"


def dms_to_dec(sign, degrees, minutes, seconds):
    """
    Convert degrees, minutes, seconds to decimal degrees and apply the given
    sign.

    Parameters
    ----------
    sign : float
        Should be 1 or -1

    degrees : float
        Degrees specification

    minutes : float
        Minutes specification (should be 0-59)

    seconds : float
        Seconds specification (should be 0-59)

    Returns
    -------
    decimal : float
        Decimal degrees representation for the given degrees, minutes, seconds
    """
    scale_factor = 1e6
    scaled_deg = abs(degrees) * scale_factor
    scaled_min = abs(minutes) * scale_factor
    scaled_sec = abs(seconds) * scale_factor
    return (
        sign * round((scaled_deg + scaled_min / 60 + scaled_sec / 3600)) / scale_factor
    )


def get_latitude_dec_from_dms(dms):
    """
    Return latitude in decimal degrees from degree, minute, seconds
    specification DDMMSS[NS].

    Parameters
    ----------
    dms : string
        Formatted string DDMMSS[NS], where DD are the degrees, MM are the
        minutes, SS are the seconds followed by the character N or S.

    Returns
    -------
    longitude : float
        Decimal representation of the input string.

    Raises
    ------
    ValueError
        If dms doesn't match the described pattern
    """
    lat_match = re.match(LATITUDE_DMS_PATTERN, dms)
    if not lat_match:
        raise ValueError(f"{dms} doesn't match {LATITUDE_DMS_PATTERN}")
    degrees = float(lat_match.group(1))
    minutes = float(lat_match.group(2))
    seconds = float(lat_match.group(3))
    # -1 if S, 1 if not S
    sign = (-1) ** (lat_match.group(4) == "S")
    return dms_to_dec(sign, degrees, minutes, seconds)


def get_longitude_dec_from_dms(dms):
    """
    Return longtitude in decimal degrees from degree, minute, seconds
    specification DDDMMSS[EW].

    Parameters
    ----------
    dms : string
        Formatted string DDDMMSS[EW], where DDD are the degrees, MM are the
        minutes, SS are the seconds followed by the character E or W.

    Returns
    -------
    longitude : float
        Decimal representation of the input string.

    Raises
    ------
    ValueError
        If dms doesn't match the described pattern
    """
    lon_match = re.match(LONGITUDE_DMS_PATTERN, dms)
    if not lon_match:
        raise ValueError(f"{dms} doesn't match {LATITUDE_DMS_PATTERN}")
    degrees = float(lon_match.group(1))
    minutes = float(lon_match.group(2))
    seconds = float(lon_match.group(3))
    # -1 if W, 1 if not W
    sign = (-1) ** (lon_match.group(4) == "W")
    return dms_to_dec(sign, degrees, minutes, seconds)
